{
  "reportUid": "TzDpuyGLrTi",
  "labels": [
    {
      "name": "QA (Quality Assurance)",
      "color": "1D76DB"
    }
  ],
  "comment": "üî•",
  "footnote": null,
  "findings": [
    {
      "severity": "Low",
      "title": "Centralization risk for trusted owners",
      "description": "Contracts have owners with privileged rights to perform admin tasks and need to be trusted to not perform malicious updates or drain funds.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit onlyEntryPoint\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n/// @audit onlyEntryPoint\n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost) \n144:         external\n145:         onlyEntryPoint\n146:     {\n/// @audit onlyOwner\n203:     function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner { \n/// @audit onlyOwner\n212:     function entryPointDeposit(uint256 amount) external payable onlyOwner { \n/// @audit onlyOwner\n222:     function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner { \n/// @audit onlyOwner\n232:     function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner { \n/// @audit onlyOwner\n239:     function entryPointUnlockStake() external onlyOwner { \n/// @audit onlyOwner\n248:     function entryPointWithdrawStake(address payable to) external onlyOwner { \n```\n",
          "loc": [
            "[222](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L222-L222)",
            "[232](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L232-L232)",
            "[239](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L239-L239)",
            "[248](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L248-L248)",
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L113)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L143-L146)",
            "[203](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L203-L203)",
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L212-L212)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit onlyEntryPoint\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n/// @audit onlyEntryPoint\n180:     function executeWithoutChainIdValidation(bytes calldata data) public payable virtual onlyEntryPoint { \n/// @audit onlyEntryPointOrOwner\n196:     function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner { \n/// @audit onlyEntryPointOrOwner\n205:     function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner { \n/// @audit onlyOwner\n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {} \n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L144)",
            "[330](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L330-L330)",
            "[205](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L205-L205)",
            "[196](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L196-L196)",
            "[180](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L180-L180)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit onlyOwner\n85:     function addOwnerAddress(address owner) public virtual onlyOwner { \n/// @audit onlyOwner\n93:     function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner { \n/// @audit onlyOwner\n102:     function removeOwnerAtIndex(uint256 index) public virtual onlyOwner { \n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L102-L102)",
            "[85](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L85-L85)",
            "[93](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L93-L93)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Consider bounding input array length",
      "description": "The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to `require()` that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit calls.length not bounded\n206:         for (uint256 i; i < calls.length;) { \n207:             _call(calls[i].target, calls[i].value, calls[i].data);\n208:             unchecked {\n209:                 ++i;\n210:             }\n211:         }\n```\n",
          "loc": [
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L206-L211)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Consider disabling `renounceOwnership()`",
      "description": "Typically, the contract's owner is the account that deploys the contract. As a result, the owner is able to perform certain privileged activities. The OpenZeppelin's `Ownable` is used in this project contract implements `renounceOwnership`. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n18: contract MagicSpend is Ownable, IPaymaster { \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18-L18)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L20)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "`constructor`/`initialize` function lacks parameter validation",
      "description": "Constructors and initialization functions play a critical role in contracts by setting important initial states when the contract is first deployed before the system starts. The parameters passed to the constructor and initialization functions directly affect the behavior of the contract / protocol. If incorrect parameters are provided, the system may fail to run, behave abnormally, be unstable, or lack security. Therefore, it's crucial to carefully check each parameter in the constructor and initialization functions. If an exception is found, the transaction should be rolled back.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit _owner \n101:     constructor(address _owner) { \n```\n",
          "loc": [
            "[101](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L101-L101)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit owners \n114:     function initialize(bytes[] calldata owners) public payable virtual { \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L114-L114)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit erc4337 \n24:     constructor(address erc4337) payable { \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L24-L24)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Deleting mapping in struct will not delete the mapping",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n106:         delete _getMultiOwnableStorage().isOwner[owner]; \n107:         delete _getMultiOwnableStorage().ownerAtIndex[index];\n```\n",
          "loc": [
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L106-L107)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Low level calls to custom `address`es",
      "description": "Low-level calls (such as `.call()`, `.delegatecall()`, or `.callcode()`) in Solidity provide a way to interact with other contracts or addresses. However, when these calls are made to addresses that are provided as parameters or are not well-validated, they pose a significant security risk. Untrusted addresses might contain malicious code leading to unexpected behavior, loss of funds, or vulnerabilities.\n\n**Resolution**: Prefer using high-level Solidity function calls or interface-based interactions with known contracts to ensure security. If low-level calls are necessary, rigorously validate the addresses and test all possible interactions. Implementing additional checks and fail-safes can help mitigate potential risks associated with low-level calls.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit low level call to 'target' on line 273\n272:     function _call(address target, uint256 value, bytes memory data) internal { \n273:         (bool success, bytes memory result) = target.call{value: value}(data);\n274:         if (!success) {\n275:             assembly (\"memory-safe\") {\n276:                 revert(add(result, 32), mload(result))\n277:             }\n278:         }\n279:     }\n```\n",
          "loc": [
            "[272](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L272-L279)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing contract-existence checks before low-level calls",
      "description": "Low-level calls return success if there is no code present at the specified address.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit line 273\n272:     function _call(address target, uint256 value, bytes memory data) internal { \n273:         (bool success, bytes memory result) = target.call{value: value}(data);\n274:         if (!success) {\n275:             assembly (\"memory-safe\") {\n276:                 revert(add(result, 32), mload(result))\n277:             }\n278:         }\n279:     }\n```\n",
          "loc": [
            "[272](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L272-L279)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing `_disableInitializer()` in upgradeable constructor body",
      "description": "Avoid leaving a contract uninitialized.\nAn uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke the `_disableInitializers()` function in the constructor to automatically lock it when it is deployed.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n102:     constructor() { \n103:         // Implementation should not be initializable (does not affect proxies which use their own storage).\n104:         bytes[] memory owners = new bytes[](1);\n105:         owners[0] = abi.encode(address(0));\n106:         _initializeOwners(owners);\n107:     }\n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L102-L107)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Missing zero address check in functions with address parameters",
      "description": "Adding a zero address check for each address type parameter can prevent errors.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit asset, to\n203:     function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner { \n/// @audit account\n260:     function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest) \n261:         public\n262:         view\n263:         returns (bool)\n264:     {\n/// @audit account\n279:     function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) { \n/// @audit account\n299:     function nonceUsed(address account, uint256 nonce) external view returns (bool) { \n/// @audit account\n315:     function _validateRequest(address account, WithdrawRequest memory withdrawRequest) internal { \n/// @audit asset, to\n334:     function _withdraw(address asset, address to, uint256 amount) internal { \n```\n",
          "loc": [
            "[279](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L279-L279)",
            "[299](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L299-L299)",
            "[260](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L260-L264)",
            "[315](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L315-L315)",
            "[203](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L203-L203)",
            "[334](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L334-L334)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit target\n196:     function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner { \n/// @audit target\n272:     function _call(address target, uint256 value, bytes memory data) internal { \n```\n",
          "loc": [
            "[196](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L196-L196)",
            "[272](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L272-L272)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit owner\n85:     function addOwnerAddress(address owner) public virtual onlyOwner { \n/// @audit account\n117:     function isOwnerAddress(address account) public view virtual returns (bool) { \n```\n",
          "loc": [
            "[85](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L85-L85)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L117-L117)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "`onlyOwner` functions not accessible if `owner` renounces ownership",
      "description": "The `owner` is able to perform certain privileged activities, but it's possible to set the owner to `address(0)`. This can represent a certain risk if the ownership is renounced for any other reason than by design.\n\nRenouncing ownership will leave the contract without an `owner`, therefore limiting any functionality that needs authority.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n203:     function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner { \n212:     function entryPointDeposit(uint256 amount) external payable onlyOwner { \n222:     function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner { \n232:     function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner { \n239:     function entryPointUnlockStake() external onlyOwner { \n248:     function entryPointWithdrawStake(address payable to) external onlyOwner { \n```\n",
          "loc": [
            "[203](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L203-L203)",
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L212-L212)",
            "[222](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L222-L222)",
            "[232](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L232-L232)",
            "[239](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L239-L239)",
            "[248](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L248-L248)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n196:     function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner { \n205:     function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner { \n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {} \n```\n",
          "loc": [
            "[196](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L196-L196)",
            "[205](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L205-L205)",
            "[330](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L330-L330)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "`pure` function accesses storage",
      "description": "While the compiler currently flags functions like these as being `pure`, this is a [bug](https://github.com/ethereum/solidity/issues/11573) which will be fixed in a future version, so it's best to not use `pure` visibility, in order to not break when this bug is fixed.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n212:     function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) { \n213:         assembly (\"memory-safe\") {\n214:             $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n215:         }\n216:     }\n```\n",
          "loc": [
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L212-L216)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "`require()` should be used instead of `assert()`",
      "description": "Prior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\".",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n150:         assert(mode != PostOpMode.postOpReverted); \n```\n",
          "loc": [
            "[150](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L150)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Some tokens may revert when zero value transfers are made",
      "description": "In spite of the fact that EIP-20 [states](https://github.com/ethereum/EIPs/blob/46b9b698815abbfa628cd1097311deee77dd45c5/EIPS/eip-20.md?plain=1#L116) that zero-valued transfers must be accepted, some tokens, such as `LEND` will revert if this is attempted, which may cause transactions that involve other tokens (such as batch operations) to fully revert. Consider skipping the transfer if the amount is zero, which will also save **gas**.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n338:             SafeTransferLib.safeTransfer(asset, to, amount); \n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L338-L338)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Unused/empty `receive()/fallback()` function",
      "description": "If the intention is for the Ether to be used, the function should call another function or emit an event, otherwise it should revert.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n106:     receive() external payable {} \n```\n",
          "loc": [
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L106-L106)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Upgradeable contract is missing a `__gap[50]` storage variable at the end to allow for new storage variables in later versions",
      "description": "See [this](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps) link for a description of this storage variable. While some contracts may not currently be sub-classed, adding the variable now protects against forgetting to add it in the future.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n21:     /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n22:     struct SignatureWrapper {\n23:         /// @dev The index indentifying owner (see MultiOwnable) who signed.\n24:         uint256 ownerIndex;\n25:         /// @dev An ABI encoded ECDSA signature (r, s, v) or WebAuthnAuth struct.\n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L25)"
          ]
        }
      ]
    },
    {
      "severity": "Low",
      "title": "Use `Ownable2Step` rather than `Ownable`",
      "description": "[`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3d7a93876a2e5e1d7fe29b5a0e96e222afdc4cfa/contracts/access/Ownable2Step.sol#L31-L56) and [`Ownable2StepUpgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/access/Ownable2StepUpgradeable.sol#L47-L63) prevent the contract ownership from mistakenly being transferred to an address that cannot handle it (e.g. due to a typo in the address), by requiring that the recipient of the owner permissions actively accept via a contract call of its own.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n18: contract MagicSpend is Ownable, IPaymaster { \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18-L18)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Add inline comments for unnamed variables",
      "description": "`function foo(address x, address)` -> `function foo(address x, address /* y */)`",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L113)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {} \n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L330-L330)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`address` shouldn't be hard-coded",
      "description": "It is often better to declare `address`es as `immutable` (instead of constant), and assign them via constructor arguments. This allows the code to remain the same across deployments on different networks, and avoids recompilation when addresses need to change.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit 0x0000000000000000000000000000000000000005\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005; \n```\n",
          "loc": [
            "[29](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L29-L29)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\n305:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789; \n```\n",
          "loc": [
            "[305](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L305-L305)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789\n218:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789; \n```\n",
          "loc": [
            "[218](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L218-L218)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Assembly block creates dirty bits",
      "description": "Writing data to the free memory pointer without later updating the free memory pointer will cause there to be dirty bits at that memory location. Not updating the free memory pointer will make it [harder](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#cleanup) for the optimizer to reason about whether the memory needs to be cleaned before use, which will lead to worse optimizations.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n95:         assembly { \n96:             let pointer := mload(0x40)\n97:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n98:             mstore(pointer, 0x20)\n99:             mstore(add(pointer, 0x20), 0x20)\n100:             mstore(add(pointer, 0x40), 0x20)\n101:             // Define variables base, exponent and modulus\n102:             mstore(add(pointer, 0x60), u)\n103:             mstore(add(pointer, 0x80), minus_2modn)\n104:             mstore(add(pointer, 0xa0), n)\n105: \n106:             // Call the precompiled contract 0x05 = ModExp\n107:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n108:             result := mload(pointer)\n109:         }\n140:             assembly { \n141:                 for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n142:                     index := sub(index, 1)\n143:                     T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n144:                 } {}\n145:                 zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n146: \n147:                 if eq(zz, 1) {\n148:                     X := gx\n149:                     Y := gy\n150:                 }\n151:                 if eq(zz, 2) {\n152:                     X := Q0\n153:                     Y := Q1\n154:                 }\n155:                 if eq(zz, 3) {\n156:                     X := H0\n157:                     Y := H1\n158:                 }\n159: \n160:                 index := sub(index, 1)\n161:                 zz := 1\n162:                 zzz := 1\n163: \n164:                 for {} gt(minus_1, index) { index := sub(index, 1) } {\n165:                     // inlined EcZZ_Dbl\n166:                     let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n167:                     let T2 := mulmod(T1, T1, p) // V=U^2\n168:                     let T3 := mulmod(X, T2, p) // S = X1*V\n169:                     T1 := mulmod(T1, T2, p) // W=UV\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n173: \n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n177: \n178:                     {\n179:                         //value of dibit\n180:                         T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n181: \n182:                         if iszero(T4) {\n183:                             Y := sub(p, Y) //restore the -Y inversion\n184:                             continue\n185:                         } // if T4!=0\n186: \n187:                         if eq(T4, 1) {\n188:                             T1 := gx\n189:                             T2 := gy\n190:                         }\n191:                         if eq(T4, 2) {\n192:                             T1 := Q0\n193:                             T2 := Q1\n194:                         }\n195:                         if eq(T4, 3) {\n196:                             T1 := H0\n197:                             T2 := H1\n198:                         }\n199:                         if iszero(zz) {\n200:                             X := T1\n201:                             Y := T2\n202:                             zz := 1\n203:                             zzz := 1\n204:                             continue\n205:                         }\n206:                         // inlined EcZZ_AddN\n207: \n208:                         //T3:=sub(p, Y)\n209:                         //T3:=Y\n210:                         let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n212: \n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n214:                         //todo : construct edge vector case\n215:                         if iszero(y2) {\n216:                             if iszero(T2) {\n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n220: \n221:                                 T1 := mulmod(T1, T2, p) // W=UV\n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n224: \n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n227: \n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n230: \n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n232: \n233:                                 continue\n234:                             }\n235:                         }\n236: \n237:                         T4 := mulmod(T2, T2, p) //PP\n238:                         let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n239:                         zz := mulmod(zz, T4, p)\n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n241:                         let TT2 := mulmod(X, T4, p)\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n244: \n245:                         X := T4\n246:                     }\n247:                 } //end loop\n248:                 let T := mload(0x40)\n249:                 mstore(add(T, 0x60), zz)\n250:                 //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n251:                 //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n252:                 // Define length of base, exponent and modulus. 0x20 == 32 bytes\n253:                 mstore(T, 0x20)\n254:                 mstore(add(T, 0x20), 0x20)\n255:                 mstore(add(T, 0x40), 0x20)\n256:                 // Define variables base, exponent and modulus\n257:                 //mstore(add(pointer, 0x60), u)\n258:                 mstore(add(T, 0x80), minus_2)\n259:                 mstore(add(T, 0xa0), p)\n260: \n261:                 // Call the precompiled contract 0x05 = ModExp\n262:                 if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n263: \n264:                 //Y:=mulmod(Y,zzz,p)//Y/zzz\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z\n266:                 //zz:= mulmod(zz,zz,p) //1/zz\n267:                 X := mulmod(X, mload(T), p) //X/zz\n268:             } //end assembly\n375:         assembly { \n376:             let pointer := mload(0x40)\n377:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n378:             mstore(pointer, 0x20)\n379:             mstore(add(pointer, 0x20), 0x20)\n380:             mstore(add(pointer, 0x40), 0x20)\n381:             // Define variables base, exponent and modulus\n382:             mstore(add(pointer, 0x60), u)\n383:             mstore(add(pointer, 0x80), minus_2)\n384:             mstore(add(pointer, 0xa0), p)\n385: \n386:             // Call the precompiled contract 0x05 = ModExp\n387:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n388:             result := mload(pointer)\n389:         }\n```\n",
          "loc": [
            "[95](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L95-L109)",
            "[140](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L140-L268)",
            "[375](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L375-L389)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Assembly blocks should have extensive comments",
      "description": "Assembly blocks take a lot more time to audit than normal Solidity code, and often have gotchas and side-effects that the Solidity versions of the same code do not. Consider adding more comments explaining what is being done in every step of the assembly code, and describe why assembly is being used instead of Solidity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n95:         assembly { \n96:             let pointer := mload(0x40)\n97:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n98:             mstore(pointer, 0x20)\n99:             mstore(add(pointer, 0x20), 0x20)\n100:             mstore(add(pointer, 0x40), 0x20)\n101:             // Define variables base, exponent and modulus\n102:             mstore(add(pointer, 0x60), u)\n103:             mstore(add(pointer, 0x80), minus_2modn)\n104:             mstore(add(pointer, 0xa0), n)\n105: \n106:             // Call the precompiled contract 0x05 = ModExp\n107:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n108:             result := mload(pointer)\n109:         }\n140:             assembly { \n141:                 for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n142:                     index := sub(index, 1)\n143:                     T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n144:                 } {}\n145:                 zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n146: \n147:                 if eq(zz, 1) {\n148:                     X := gx\n149:                     Y := gy\n150:                 }\n151:                 if eq(zz, 2) {\n152:                     X := Q0\n153:                     Y := Q1\n154:                 }\n155:                 if eq(zz, 3) {\n156:                     X := H0\n157:                     Y := H1\n158:                 }\n159: \n160:                 index := sub(index, 1)\n161:                 zz := 1\n162:                 zzz := 1\n163: \n164:                 for {} gt(minus_1, index) { index := sub(index, 1) } {\n165:                     // inlined EcZZ_Dbl\n166:                     let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n167:                     let T2 := mulmod(T1, T1, p) // V=U^2\n168:                     let T3 := mulmod(X, T2, p) // S = X1*V\n169:                     T1 := mulmod(T1, T2, p) // W=UV\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n173: \n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n177: \n178:                     {\n179:                         //value of dibit\n180:                         T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n181: \n182:                         if iszero(T4) {\n183:                             Y := sub(p, Y) //restore the -Y inversion\n184:                             continue\n185:                         } // if T4!=0\n186: \n187:                         if eq(T4, 1) {\n188:                             T1 := gx\n189:                             T2 := gy\n190:                         }\n191:                         if eq(T4, 2) {\n192:                             T1 := Q0\n193:                             T2 := Q1\n194:                         }\n195:                         if eq(T4, 3) {\n196:                             T1 := H0\n197:                             T2 := H1\n198:                         }\n199:                         if iszero(zz) {\n200:                             X := T1\n201:                             Y := T2\n202:                             zz := 1\n203:                             zzz := 1\n204:                             continue\n205:                         }\n206:                         // inlined EcZZ_AddN\n207: \n208:                         //T3:=sub(p, Y)\n209:                         //T3:=Y\n210:                         let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n212: \n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n214:                         //todo : construct edge vector case\n215:                         if iszero(y2) {\n216:                             if iszero(T2) {\n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n220: \n221:                                 T1 := mulmod(T1, T2, p) // W=UV\n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n224: \n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n227: \n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n230: \n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n232: \n233:                                 continue\n234:                             }\n235:                         }\n236: \n237:                         T4 := mulmod(T2, T2, p) //PP\n238:                         let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n239:                         zz := mulmod(zz, T4, p)\n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n241:                         let TT2 := mulmod(X, T4, p)\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n244: \n245:                         X := T4\n246:                     }\n247:                 } //end loop\n248:                 let T := mload(0x40)\n249:                 mstore(add(T, 0x60), zz)\n250:                 //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n251:                 //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n252:                 // Define length of base, exponent and modulus. 0x20 == 32 bytes\n253:                 mstore(T, 0x20)\n254:                 mstore(add(T, 0x20), 0x20)\n255:                 mstore(add(T, 0x40), 0x20)\n256:                 // Define variables base, exponent and modulus\n257:                 //mstore(add(pointer, 0x60), u)\n258:                 mstore(add(T, 0x80), minus_2)\n259:                 mstore(add(T, 0xa0), p)\n260: \n261:                 // Call the precompiled contract 0x05 = ModExp\n262:                 if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n263: \n264:                 //Y:=mulmod(Y,zzz,p)//Y/zzz\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z\n266:                 //zz:= mulmod(zz,zz,p) //1/zz\n267:                 X := mulmod(X, mload(T), p) //X/zz\n268:             } //end assembly\n375:         assembly { \n376:             let pointer := mload(0x40)\n377:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n378:             mstore(pointer, 0x20)\n379:             mstore(add(pointer, 0x20), 0x20)\n380:             mstore(add(pointer, 0x40), 0x20)\n381:             // Define variables base, exponent and modulus\n382:             mstore(add(pointer, 0x60), u)\n383:             mstore(add(pointer, 0x80), minus_2)\n384:             mstore(add(pointer, 0xa0), p)\n385: \n386:             // Call the precompiled contract 0x05 = ModExp\n387:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n388:             result := mload(pointer)\n389:         }\n```\n",
          "loc": [
            "[375](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L375-L389)",
            "[95](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L95-L109)",
            "[140](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L140-L268)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n94:         assembly (\"memory-safe\") { \n95:             if missingAccountFunds {\n96:                 // Ignore failure (it's EntryPoint's job to verify, not the account's).\n97:                 pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n98:             }\n99:         }\n242:         assembly { \n243:             $ := sload(_ERC1967_IMPLEMENTATION_SLOT)\n244:         }\n275:             assembly (\"memory-safe\") { \n276:                 revert(add(result, 32), mload(result))\n277:             }\n309:             assembly (\"memory-safe\") { \n310:                 owner := mload(add(ownerBytes, 32))\n311:             }\n```\n",
          "loc": [
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L94-L99)",
            "[242](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L242-L244)",
            "[275](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L275-L277)",
            "[309](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L309-L311)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n213:         assembly (\"memory-safe\") { \n214:             $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n215:         }\n```\n",
          "loc": [
            "[213](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L213-L215)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid mutating `function`/`modifier` parameters",
      "description": "Use a local variable instead",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit scalar_u\n137:                 scalar_u = addmod(scalar_u, n - scalar_v, n); \n/// @audit scalar_v\n138:                 scalar_v = 0;\n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L137-L138)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit userOpHash\n149:             userOpHash = getUserOpHashWithoutChainId(userOp); \n```\n",
          "loc": [
            "[149](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L149-L149)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid revertible function calls in a constructor",
      "description": "It is advisable to to perform validation within the constructor itself rather than in function calls it makes. This is because contract deployement may be performed through a frontend or manually so by having all of the validation conditions viewable in a single place allows for greater transparency during deployment for both the team and project users.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n102:     constructor() { \n103:         // Implementation should not be initializable (does not affect proxies which use their own storage).\n104:         bytes[] memory owners = new bytes[](1);\n105:         owners[0] = abi.encode(address(0));\n/// @audit '_initializeOwners can revert'\n106:         _initializeOwners(owners);\n107:     }\n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L102-L107)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Avoid the use of sensitive terms",
      "description": "Use [alternative variants](https://www.zdnet.com/article/mysql-drops-master-slave-and-blacklist-whitelist-terminology/), e.g. allowlist/denylist instead of whitelist/blacklist",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n8: import {IPaymaster} from \"account-abstraction/interfaces/IPaymaster.sol\"; \n15: /// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6. \n17: /// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters. \n18: contract MagicSpend is Ownable, IPaymaster {\n73:     error UnsupportedPaymasterAsset(address asset); \n108:     /// @inheritdoc IPaymaster \n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n114:         WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest)); \n122:             revert UnsupportedPaymasterAsset(withdrawRequest.asset); \n142:     /// @inheritdoc IPaymaster \n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n```\n",
          "loc": [
            "[8](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L8-L8)",
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L15)",
            "[17](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L17-L18)",
            "[73](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L73)",
            "[108](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L108-L109)",
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L114)",
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L122)",
            "[142](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L142-L143)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n51:     /// @dev Whitelisting of `UserOperation`s that are allowed to skip the chain ID validation is \n90:     ///                            paymaster. \n247:     /// @notice Check if the given function selector is whitelisted to skip the chain ID validation. \n251:     /// @return `true` is the function selector is whitelisted to skip the chain ID validation, else `false`. \n```\n",
          "loc": [
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L51)",
            "[90](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L90)",
            "[247](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L247)",
            "[251](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L251)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n17: /// @author Daimo (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol) \n50:     ///      See https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md. \n```\n",
          "loc": [
            "[17](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L17)",
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L50)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Common functions should be refactored to a common base contract",
      "description": "The functions below have the same implementation as is seen in other files. The functions should be refactored into functions of a common base contract",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit also seen in src/SmartWallet/ERC1271.sol\n291:     function _validateSignature(bytes32 message, bytes calldata signature) \n```\n",
          "loc": [
            "[291](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L291-L291)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Complicated functions should have explicit comments",
      "description": "Large and/or complex functions should have more comments to better explain the purpose of each logic step.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit function is 155 lines long\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L122)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider adding a block/deny-list",
      "description": "Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n18: contract MagicSpend is Ownable, IPaymaster { \n19:     /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n20:     struct WithdrawRequest {\n21:         /// @dev The signature associated with this withdraw request.\n22:         bytes signature;\n23:         /// @dev The asset to withdraw. NOTE: Only ETH (associated with zero address) is supported for now.\n24:         address asset;\n25:         /// @dev The requested amount to withdraw.\n26:         uint256 amount;\n27:         /// @dev Unique nonce used to prevent replays.\n28:         uint256 nonce;\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18-L28)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n21:     /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n22:     struct SignatureWrapper {\n23:         /// @dev The index indentifying owner (see MultiOwnable) who signed.\n24:         uint256 ownerIndex;\n25:         /// @dev An ABI encoded ECDSA signature (r, s, v) or WebAuthnAuth struct.\n26:         bytes signatureData;\n27:     }\n28: \n29:     /// @notice Wrapper struct, used in `executeBatch`, describing a raw call to execute.\n30:     struct Call {\n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L30)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n13: contract CoinbaseSmartWalletFactory { \n14:     /// @notice Address of the ERC-4337 implementation used as implementation for new accounts.\n15:     address public immutable implementation;\n16: \n17:     /// @notice Thrown when trying to create a new `CoinbaseSmartWallet` account without any owner.\n18:     error OwnerRequired();\n19: \n20:     /// @notice Factory constructor used to initialize the implementation address to use for future\n21:     ///         ERC-4337 account deployments.\n22:     ///\n23:     /// @param erc4337 The address of the ERC-4337 implementation used to deploy new cloned accounts.\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13-L23)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n32: contract MultiOwnable { \n33:     /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n34:     ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n35:     ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n36:     bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n37:         0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n38: \n39:     /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n40:     error Unauthorized();\n41: \n42:     /// @notice Thrown when trying to add an already registered owner.\n```\n",
          "loc": [
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L32-L42)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider making contracts `Upgradeable`",
      "description": "This allows for bugs to be fixed in production, at the expense of *significantly* increasing centralization.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit contract MagicSpend is not upgradeable\n18: contract MagicSpend is Ownable, IPaymaster { \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18-L18)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit contract CoinbaseSmartWalletFactory is not upgradeable\n13: contract CoinbaseSmartWalletFactory { \n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13-L13)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit contract ERC1271 is not upgradeable\n16: abstract contract ERC1271 { \n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L16-L16)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit contract MultiOwnable is not upgradeable\n32: contract MultiOwnable { \n```\n",
          "loc": [
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L32-L32)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Consider using `delete` rather than assigning zero to clear values",
      "description": "The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n138:                 scalar_v = 0; \n```\n",
          "loc": [
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L138-L138)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Constants in comparisons should appear on the left side",
      "description": "Putting constants on the left side of comparison statements is a best practice known as [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions). Although solidity's static typing system prevents accidental assignments within conditionals, adopting this practice can improve code readability and consistency, especially when working across multiple languages.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit move 0 to the left\n/// @audit move 0 to the left\n51:         if (r == 0 || r >= n || s == 0 || s >= n) { \n/// @audit move 0 to the left\n/// @audit move 0 to the left\n131:             if (scalar_u == 0 && scalar_v == 0) return 0; \n/// @audit move 0 to the left\n/// @audit move 0 to the left\n134:             if ( \n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n/// @audit move 0 to the left\n350:             if (y1 == 0) { \n```\n",
          "loc": [
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L51-L51)",
            "[131](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L131-L131)",
            "[134](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L134-L135)",
            "[350](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L350-L350)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit move 0 to the left\n172:         if (amount == 0) revert NoExcess(); \n```\n",
          "loc": [
            "[172](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L172-L172)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit move 0 to the left\n115:         if (nextOwnerIndex() != 0) { \n/// @audit move 0xbf6ba1fc to the left\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) { \n/// @audit move 32 to the left\n301:         if (ownerBytes.length == 32) { \n/// @audit move 64 to the left\n316:         if (ownerBytes.length == 64) { \n```\n",
          "loc": [
            "[115](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L115-L115)",
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L148-L148)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L301-L301)",
            "[316](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L316-L316)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit move 0 to the left\n44:         if (owners.length == 0) { \n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L44-L44)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit move 0 to the left\n104:         if (owner.length == 0) revert NoOwnerAtIndex(index); \n/// @audit move 32 to the left\n/// @audit move 64 to the left\n164:             if (owners[i].length != 32 && owners[i].length != 64) { \n/// @audit move 32 to the left\n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L104-L104)",
            "[164](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L164-L164)",
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`constant`s should be defined rather than using magic numbers",
      "description": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n126:         uint256 index = 255; \n```\n",
          "loc": [
            "[126](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L126)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n114:         WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest)); \n128:         validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160); \n305:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789; \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L114)",
            "[128](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L128)",
            "[305](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L305)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n145:         uint256 key = userOp.nonce >> 64; \n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) { \n181:         bytes4 selector = bytes4(data[0:4]); \n218:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789; \n301:         if (ownerBytes.length == 32) { \n316:         if (ownerBytes.length == 64) { \n```\n",
          "loc": [
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L145)",
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L148-L148)",
            "[181](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L181)",
            "[218](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L218)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L301)",
            "[316](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L316)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n72:             return 0x1626ba7e; \n75:         return 0xffffffff; \n```\n",
          "loc": [
            "[72](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L72)",
            "[75](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L75)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n164:             if (owners[i].length != 32 && owners[i].length != 64) { \n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n```\n",
          "loc": [
            "[164](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L164-L164)",
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n116:         string memory _type = webAuthnAuth.clientDataJSON.slice(webAuthnAuth.typeIndex, webAuthnAuth.typeIndex + 21); \n133:         if (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UP != AUTH_DATA_FLAGS_UP) { \n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) { \n```\n",
          "loc": [
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L138)",
            "[116](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L116)",
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L133)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`constant`s/`immutable`s redefined elsewhere",
      "description": "Consider defining each of these in only one contract so that values cannot become out of sync when only one location is updated (i.e. having `ContA.X`,`ContB.Y` is fine since they're different constant names in different files, but `ContA.X`, `ContB.X` is not since it's the same constant defined in multiple files with the same value). Even things like `decimals` and `VERSION` can employ file-level constants such as `PREFERRED_DECIMALS = 18` and `INITIAL_VERSION = \"1.0.0\"`",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005; \n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF; \n33:     uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC; \n35:     uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B; \n37:     uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296; \n38:     uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n40:     uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551; \n42:     uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD; \n44:     uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F; \n46:     uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \n```\n",
          "loc": [
            "[29](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L29-L29)",
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L31-L31)",
            "[33](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L33-L33)",
            "[35](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L35-L35)",
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L37-L38)",
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L40-L40)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L42-L42)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L44-L44)",
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L46-L46)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n43:     uint256 public constant REPLAYABLE_NONCE_KEY = 8453; \n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L43-L43)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n15:     address public immutable implementation; \n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L15-L15)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n23:     bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"CoinbaseSmartWalletMessage(bytes32 hash)\"); \n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L23-L23)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n36:     bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION = \n37:         0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n```\n",
          "loc": [
            "[36](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L36-L37)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n40:     bytes1 private constant AUTH_DATA_FLAGS_UP = 0x01; \n44:     bytes1 private constant AUTH_DATA_FLAGS_UV = 0x04; \n47:     uint256 private constant P256_N_DIV_2 = FCL.n / 2; \n51:     address private constant VERIFIER = address(0x100); \n55:     bytes32 private constant EXPECTED_TYPE_HASH = keccak256('\"type\":\"webauthn.get\"'); \n```\n",
          "loc": [
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L40-L40)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L44-L44)",
            "[47](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L47-L47)",
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L51-L51)",
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L55-L55)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`constructor` should emit an event",
      "description": "Use events to signal significant changes to off-chain monitoring tools.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n101:     constructor(address _owner) { \n```\n",
          "loc": [
            "[101](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L101-L101)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n102:     constructor() { \n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L102-L102)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n24:     constructor(address erc4337) payable { \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L24-L24)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Contracts should have all `public`/`external` functions exposed by `interface`s",
      "description": "The `contract`s should expose an `interface` so that other projects can more easily integrate with it, without having to develop their own non-standard variants.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit validatePaymasterUserOp, postOp, withdrawGasExcess, withdraw, ownerWithdraw, entryPointDeposit, entryPointWithdraw, entryPointAddStake, entryPointUnlockStake, entryPointWithdrawStake, isValidWithdrawSignature, getHash, nonceUsed, entryPoint\n18: contract MagicSpend is Ownable, IPaymaster { \n19:     /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n20:     struct WithdrawRequest {\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18-L20)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit implementation, canSkipChainIdValidation\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n21:     /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n22:     struct SignatureWrapper {\n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L22)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit getAddress\n13: contract CoinbaseSmartWalletFactory { \n14:     /// @notice Address of the ERC-4337 implementation used as implementation for new accounts.\n15:     address public immutable implementation;\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13-L15)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit domainSeparator\n16: abstract contract ERC1271 { \n17:     /// @dev Precomputed `typeHash` used to produce EIP-712 compliant hash when applying the anti\n18:     ///      cross-account-replay layer.\n19:     ///\n20:     ///      The original hash must either be:\n21:     ///         - An EIP-191 hash: keccak256(\"\\x19Ethereum Signed Message:\\n\" || len(someMessage) || someMessage)\n22:     ///         - An EIP-712 hash: keccak256(\"\\x19\\x01\" || someDomainSeparator || hashStruct(someStruct))\n23:     bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"CoinbaseSmartWalletMessage(bytes32 hash)\");\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L16-L23)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Control structures do not follow the Solidity Style Guide",
      "description": "See the [control structures](https://docs.soliditylang.org/en/latest/style-guide.html#control-structures) section of the Solidity Style Guide",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n302:         internal\n303:         view\n304:         returns (uint256 x1, uint256 y1)\n305:     {\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n```\n",
          "loc": [
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L305)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L322)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L348)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit opening brace should be preceded by a single space\n93:     modifier onlyEntryPoint() virtual { \n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost) \n144:         external\n145:         onlyEntryPoint\n146:     {\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n260:     function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest) \n261:         public\n262:         view\n263:         returns (bool)\n264:     {\n```\n",
          "loc": [
            "[93](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L93)",
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L113)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L143-L146)",
            "[260](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L260-L264)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit opening brace should be preceded by a single space\n65:     modifier onlyEntryPoint() virtual { \n/// @audit opening brace should be preceded by a single space\n74:     modifier onlyEntryPointOrOwner() virtual { \n/// @audit opening brace should be preceded by a single space\n91:     modifier payPrefund(uint256 missingAccountFunds) virtual { \n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n291:     function _validateSignature(bytes32 message, bytes calldata signature) \n292:         internal\n293:         view\n294:         virtual\n295:         override\n296:         returns (bool)\n297:     {\n```\n",
          "loc": [
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L65)",
            "[74](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L74)",
            "[91](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L91)",
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L144)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L234)",
            "[291](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L291-L297)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n38:     function createAccount(bytes[] calldata owners, uint256 nonce) \n39:         public\n40:         payable\n41:         virtual\n42:         returns (CoinbaseSmartWallet account)\n43:     {\n```\n",
          "loc": [
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L38-L43)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n36:     function eip712Domain() \n37:         external\n38:         view\n39:         virtual\n40:         returns (\n41:             bytes1 fields,\n42:             string memory name,\n43:             string memory version,\n44:             uint256 chainId,\n45:             address verifyingContract,\n46:             bytes32 salt,\n47:             uint256[] memory extensions\n48:         )\n49:     {\n```\n",
          "loc": [
            "[36](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L36-L49)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit opening brace should be preceded by a single space\n77:     modifier onlyOwner() virtual { \n```\n",
          "loc": [
            "[77](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L77)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit opening brace should be on the same line as the declaration\n/// @audit opening brace should be preceded by a single space\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n105:         internal\n106:         view\n107:         returns (bool)\n108:     {\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L108)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Custom `error` without details",
      "description": "Consider adding some parameters to the error to indicate which user or values caused the failure.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n53:     error InvalidSignature(); \n56:     error Expired(); \n83:     error NoExcess(); \n90:     error UnexpectedPostOpRevertedMode(); \n```\n",
          "loc": [
            "[53](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L53)",
            "[56](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L56)",
            "[83](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L83)",
            "[90](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L90)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n46:     error Initialized(); \n```\n",
          "loc": [
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L46)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n18:     error OwnerRequired(); \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L18)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n40:     error Unauthorized(); \n```\n",
          "loc": [
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L40)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Empty bytes check is missing",
      "description": "Passing empty bytes to a function can cause unexpected behavior, such as certain operations failing, producing incorrect results, or wasting gas. It is recommended to check that all byte parameters are not empty.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n/// @audit context\n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost) \n144:         external\n145:         onlyEntryPoint\n146:     {\n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L113)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L143-L146)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit userOpHash\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n/// @audit data\n180:     function executeWithoutChainIdValidation(bytes calldata data) public payable virtual onlyEntryPoint { \n/// @audit data\n196:     function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner { \n/// @audit data\n272:     function _call(address target, uint256 value, bytes memory data) internal { \n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L144)",
            "[180](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L180-L180)",
            "[196](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L196-L196)",
            "[272](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L272-L272)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit x\n/// @audit y\n93:     function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner { \n/// @audit owner\n179:     function _addOwner(bytes memory owner) internal virtual { \n/// @audit owner\n189:     function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual { \n```\n",
          "loc": [
            "[93](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L93-L93)",
            "[179](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L179-L179)",
            "[189](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L189-L189)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Empty function body",
      "description": "Empty function body in solidity is not recommended, consider adding some comments to the body.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n106:     receive() external payable {} \n```\n",
          "loc": [
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L106-L106)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Enum values should be used instead of constant array indexes",
      "description": "Create a commented enum value to use instead of constant array indexes, this makes the code far easier to understand.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit 0\n105:         owners[0] = abi.encode(address(0)); \n```\n",
          "loc": [
            "[105](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L105)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit 32\n133:         if (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UP != AUTH_DATA_FLAGS_UP) { \n/// @audit 32\n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) { \n```\n",
          "loc": [
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L133)",
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L138)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Event is missing `indexed` fields",
      "description": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n45:     event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce); \n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L45-L45)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n68:     event AddOwner(uint256 indexed index, bytes owner); \n74:     event RemoveOwner(uint256 indexed index, bytes owner); \n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L68-L68)",
            "[74](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L74-L74)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Events are missing sender information",
      "description": "When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the msg.sender the events of these types of action will make events much more useful to end users, especially when `msg.sender` is not `tx.origin`.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n323:         emit MagicSpendWithdrawal(account, withdrawRequest.asset, withdrawRequest.amount, withdrawRequest.nonce); \n```\n",
          "loc": [
            "[323](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L323-L323)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n109:         emit RemoveOwner(index, owner); \n195:         emit AddOwner(index, owner); \n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L109-L109)",
            "[195](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L195-L195)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Expressions for `constant` values should use `immutable` rather than constant",
      "description": "While it does not save gas for some simple binary expressions because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n23:     bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"CoinbaseSmartWalletMessage(bytes32 hash)\"); \n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L23-L23)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n47:     uint256 private constant P256_N_DIV_2 = FCL.n / 2; \n51:     address private constant VERIFIER = address(0x100); \n55:     bytes32 private constant EXPECTED_TYPE_HASH = keccak256('\"type\":\"webauthn.get\"'); \n```\n",
          "loc": [
            "[47](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L47-L47)",
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L51-L51)",
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L55-L55)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS",
      "description": "In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit line 206\n205:     function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner { \n206:         for (uint256 i; i < calls.length;) {\n207:             _call(calls[i].target, calls[i].value, calls[i].data);\n208:             unchecked {\n209:                 ++i;\n210:             }\n211:         }\n212:     }\n```\n",
          "loc": [
            "[205](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L205-L212)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Function called does not exist in the contract interface",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n223:         IEntryPoint(entryPoint()).withdrawTo(to, amount); \n233:         IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds); \n240:         IEntryPoint(entryPoint()).unlockStake(); \n249:         IEntryPoint(entryPoint()).withdrawStake(to); \n```\n",
          "loc": [
            "[223](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L223-L223)",
            "[233](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L233-L233)",
            "[240](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L240-L240)",
            "[249](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L249-L249)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Function ordering in the contract does not follow the Solidity style guide",
      "description": "Source: [https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-layout](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-layout)",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n106:     receive() external payable {} \n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost) \n169:     function withdrawGasExcess() external { \n181:     function withdraw(WithdrawRequest memory withdrawRequest) external { \n203:     function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner { \n212:     function entryPointDeposit(uint256 amount) external payable onlyOwner { \n222:     function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner { \n232:     function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner { \n239:     function entryPointUnlockStake() external onlyOwner { \n248:     function entryPointWithdrawStake(address payable to) external onlyOwner { \n299:     function nonceUsed(address account, uint256 nonce) external view returns (bool) { \n```\n",
          "loc": [
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L106)",
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L143)",
            "[169](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L169)",
            "[181](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L181)",
            "[203](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L203)",
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L212)",
            "[222](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L222)",
            "[232](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L232)",
            "[239](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L239)",
            "[248](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L248)",
            "[299](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L299)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n64:     function getAddress(bytes[] calldata owners, uint256 nonce) external view returns (address predicted) { \n```\n",
          "loc": [
            "[64](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L64)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions not used internally could be marked external",
      "description": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n241:     function implementation() public view returns (address $) { \n```\n",
          "loc": [
            "[241](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L241-L241)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Functions should be named in mixedCase style",
      "description": "According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) function names should be in `mixedCase` (lowerCamelCase)Rule exceptions\n- Allow `_` at the beginning of the mixedCase match for `private`/`internal` functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit ecdsa_verify\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n/// @audit ecAff_isOnCurve\n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n/// @audit FCL_nModInv\n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n/// @audit ecZZ_mulmuladd_S_asm\n117:     function ecZZ_mulmuladd_S_asm( \n/// @audit ecAff_add\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n/// @audit ecAff_IsZero\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n/// @audit ecZZ_SetAff\n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n/// @audit ecZZ_Dbl\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n/// @audit ecZZ_AddN\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n/// @audit FCL_pModInv\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L78)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L94)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L117)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L293)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L301)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L318)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L344)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L374)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "High cyclomatic complexity",
      "description": "Functions with high cyclomatic complexity are harder to understand, test, and maintain. Consider breaking down these blocks into more manageable units, by splitting things into utility functions, by reducing nesting, and by using early returns.\n\n[Learn More About Cyclomatic Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n114:         WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest));\n115:         uint256 withdrawAmount = withdrawRequest.amount;\n116: \n117:         if (withdrawAmount < maxCost) {\n118:             revert RequestLessThanGasMaxCost(withdrawAmount, maxCost);\n119:         }\n120: \n121:         if (withdrawRequest.asset != address(0)) {\n122:             revert UnsupportedPaymasterAsset(withdrawRequest.asset);\n123:         }\n124: \n125:         _validateRequest(userOp.sender, withdrawRequest);\n126: \n127:         bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest);\n128:         validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160);\n129: \n130:         // Ensure at validation that the contract has enough balance to cover the requested funds.\n131:         // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n132:         //       when `postOp()` is called back after the `UserOperation` has been executed.\n133:         if (address(this).balance < withdrawAmount) {\n134:             revert InsufficientBalance(withdrawAmount, address(this).balance);\n135:         }\n136: \n137:         // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`.\n138:         _withdrawableETH[userOp.sender] += withdrawAmount - maxCost;\n139:         context = abi.encode(maxCost, userOp.sender);\n140:     }\n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L140)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n145:         uint256 key = userOp.nonce >> 64;\n146: \n147:         // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n149:             userOpHash = getUserOpHashWithoutChainId(userOp);\n150:             if (key != REPLAYABLE_NONCE_KEY) {\n151:                 revert InvalidNonceKey(key);\n152:             }\n153:         } else {\n154:             if (key == REPLAYABLE_NONCE_KEY) {\n155:                 revert InvalidNonceKey(key);\n156:             }\n157:         }\n158: \n159:         // Return 0 if the recovered address matches the owner.\n160:         if (_validateSignature(userOpHash, userOp.signature)) {\n161:             return 0;\n162:         }\n163: \n164:         // Else return 1, which is equivalent to:\n165:         // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n166:         // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n167:         return 1;\n168:     }\n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L168)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n105:         internal\n106:         view\n107:         returns (bool)\n108:     {\n109:         if (webAuthnAuth.s > P256_N_DIV_2) {\n110:             // guard against signature malleability\n111:             return false;\n112:         }\n113: \n114:         // 11. Verify that the value of C.type is the string webauthn.get.\n115:         // bytes(\"type\":\"webauthn.get\").length = 21\n116:         string memory _type = webAuthnAuth.clientDataJSON.slice(webAuthnAuth.typeIndex, webAuthnAuth.typeIndex + 21);\n117:         if (keccak256(bytes(_type)) != EXPECTED_TYPE_HASH) {\n118:             return false;\n119:         }\n120: \n121:         // 12. Verify that the value of C.challenge equals the base64url encoding of options.challenge.\n122:         bytes memory expectedChallenge = bytes(string.concat('\"challenge\":\"', Base64.encodeURL(challenge), '\"'));\n123:         string memory actualChallenge = webAuthnAuth.clientDataJSON.slice(\n124:             webAuthnAuth.challengeIndex, webAuthnAuth.challengeIndex + expectedChallenge.length\n125:         );\n126:         if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) {\n127:             return false;\n128:         }\n129: \n130:         // Skip 13., 14., 15.\n131: \n132:         // 16. Verify that the UP bit of the flags in authData is set.\n133:         if (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UP != AUTH_DATA_FLAGS_UP) {\n134:             return false;\n135:         }\n136: \n137:         // 17. If user verification is required for this assertion, verify that the User Verified bit of the flags in authData is set.\n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) {\n139:             return false;\n140:         }\n141: \n142:         // skip 18.\n143: \n144:         // 19. Let hash be the result of computing a hash over the cData using SHA-256.\n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON));\n146: \n147:         // 20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData and hash.\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash));\n149:         bytes memory args = abi.encode(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n150:         // try the RIP-7212 precompile address\n151:         (bool success, bytes memory ret) = VERIFIER.staticcall(args);\n152:         // staticcall will not revert if address has no code\n153:         // check return length\n154:         // note that even if precompile exists, ret.length is 0 when verification returns false\n155:         // so an invalid signature will be checked twice: once by the precompile and once by FCL.\n156:         // Ideally this signature failure is simulated offchain and no one actually pay this gas.\n157:         bool valid = ret.length > 0;\n158:         if (success && valid) return abi.decode(ret, (uint256)) == 1;\n159: \n160:         return FCL.ecdsa_verify(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n161:     }\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L161)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`if`-statement can be converted to a ternary",
      "description": "The code can be made more compact while also increasing readability by converting the following `if`-statements to ternaries (e.g. `foo += (x > y) ? a : b`)",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n335:         if (asset == address(0)) { \n336:             SafeTransferLib.safeTransferETH(to, amount);\n337:         } else {\n338:             SafeTransferLib.safeTransfer(asset, to, amount);\n339:         }\n```\n",
          "loc": [
            "[335](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L335-L339)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Imports could be organized more systematically",
      "description": "The contract's interface should be imported first, followed by each of the interfaces it uses, followed by all other files. The examples below do not follow this layout.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n2: pragma solidity 0.8.23; \n3: \n4: import {Ownable} from \"solady/auth/Ownable.sol\";\n5: import {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\n6: import {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n7: import {UserOperation} from \"account-abstraction/interfaces/UserOperation.sol\";\n8: import {IPaymaster} from \"account-abstraction/interfaces/IPaymaster.sol\";\n9: import {IEntryPoint} from \"account-abstraction/interfaces/IEntryPoint.sol\";\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L2-L9)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n2: pragma solidity 0.8.23; \n3: \n4: import {Receiver} from \"solady/accounts/Receiver.sol\";\n5: import {UUPSUpgradeable} from \"solady/utils/UUPSUpgradeable.sol\";\n6: import {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\n7: import {UserOperation, UserOperationLib} from \"account-abstraction/interfaces/UserOperation.sol\";\n8: import {WebAuthn} from \"../WebAuthnSol/WebAuthn.sol\";\n9: \n10: import {ERC1271} from \"./ERC1271.sol\";\n11: import {MultiOwnable} from \"./MultiOwnable.sol\";\n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L2-L11)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Inconsistent method of specifying a floating pragma",
      "description": "Some files use >=, while others use ^. The instances below are examples of the method that has the fewest instances for a specific version.\n\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n24: pragma solidity >=0.8.19 <0.9.0; \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L24)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Inconsistent spacing in comments",
      "description": "Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Space: `7`\n/// @audit No space: `42`\n1: //curve order (number of points) \n4: // | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__ \n5: // | _| '_/ -_|_-< ' \\  | (__| '_| || | '_ \\  _/ _ \\ | |__| | '_ \\\n6: // |_||_| \\___/__/_||_|  \\___|_|  \\_, | .__/\\__\\___/ |____|_|_.__/\n19: // Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced \n20: // if ever used for other curve than sec256R1\n21: // Abstract: https://eprint.iacr.org/2023/939.pdf\n22: // Github code: https://github.com/rdubois-crypto/FreshCryptoLib/blob/d9bb3b0fc6b737af2c70dab246cabbc7d05afc3c/solidity/src/FCL_ecdsa.sol#L40\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L1-L1)",
            "[4](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L4-L6)",
            "[19](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L19-L22)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit Space: `4`\n/// @audit No space: `140`\n1: // SPDX-License-Identifier: MIT \n11: /// @title Magic Spend \n13: /// @author Coinbase (https://github.com/coinbase/magic-spend) \n15: /// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6. \n17: /// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters. \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L1-L1)",
            "[11](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L11)",
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L13)",
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L15)",
            "[17](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L17)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Space: `5`\n/// @audit No space: `127`\n1: // SPDX-License-Identifier: MIT \n13: /// @title Coinbase Smart Wallet \n15: /// @notice ERC4337-compatible smart contract wallet, based on Solady ERC4337 account implementation \n16: ///         with inspiration from Alchemy's LightAccount and Daimo's DaimoAccount.\n18: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n19: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L1-L1)",
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L13)",
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L15-L16)",
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L18-L19)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit Space: `4`\n/// @audit No space: `31`\n1: // SPDX-License-Identifier: MIT \n7: /// @title Coinbase Smart Wallet Factory \n9: /// @notice CoinbaseSmartWallet factory, based on Solady's ERC4337Factory. \n11: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n12: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337Factory.sol)\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L1-L1)",
            "[7](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L7)",
            "[9](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L9)",
            "[11](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L11-L12)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit Space: `9`\n/// @audit No space: `79`\n1: // SPDX-License-Identifier: MIT \n4: /// @title ERC-1271 With Cross Account Replay Protection \n6: /// @notice Abstract ERC-1271 implementation (based on Solady's) with guards to handle the same \n7: ///         signer being used on multiple accounts.\n9: /// @dev To prevent the same signature from being validated on different accounts owned by the samer signer, \n10: ///      we introduce an anti cross-account-replay layer: the original hash is input into a new EIP-712 compliant\n11: ///      hash. The domain separator of this outer hash contains the chain id and address of this contract, so that\n12: ///      it cannot be used on two accounts (see `replaySafeHash()` for the implementation details).\n14: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n15: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)\n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L9-L12)",
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L1-L1)",
            "[4](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L4)",
            "[6](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L6-L7)",
            "[14](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L14-L15)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit Space: `5`\n/// @audit No space: `98`\n1: // SPDX-License-Identifier: MIT \n4: /// @notice Storage layout used by this contract. \n6: /// @custom:storage-location erc7201:coinbase.storage.MultiOwnable \n27: /// @title Multi Ownable \n29: /// @notice Auth contract allowing multiple owners, each identified as bytes. \n31: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L1-L1)",
            "[4](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L4)",
            "[6](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L6)",
            "[27](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L27)",
            "[29](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L29)",
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L31)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit Space: `7`\n/// @audit No space: `80`\n1: // SPDX-License-Identifier: MIT \n8: /// @title WebAuthn \n10: /// @notice A library for verifying WebAuthn Authentication Assertions, built off the work \n11: ///         of Daimo.\n13: /// @dev Attempts to use the RIP-7212 precompile for signature verification. \n14: ///      If precompile verification fails, it falls back to FreshCryptoLib.\n16: /// @author Coinbase (https://github.com/base-org/webauthn-sol) \n17: /// @author Daimo (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)\n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L1-L1)",
            "[8](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L8)",
            "[10](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L10-L11)",
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L13-L14)",
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L16-L17)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Large numeric literals should use underscores for readability",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n43:     uint256 public constant REPLAYABLE_NONCE_KEY = 8453; \n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L43)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Layout order does not comply with best practices",
      "description": "This is a [best practice](https://docs.soliditylang.org/en/latest/style-guide.html#order-of-layout) that should be followed.\n\nInside each contract, library or interface, use the following order:\n\n1. Type declarations\n2. State variables\n3. Events\n4. Errors\n5. Modifiers\n6. Functions",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit struct declaration `Call` after variable declaration\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L20)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Lines are too long",
      "description": "Usually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over 164 characters, the lines below should be split when they reach that length Reference: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#maximum-line-length",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit 141 chars long\n22: // Github code: https://github.com/rdubois-crypto/FreshCryptoLib/blob/d9bb3b0fc6b737af2c70dab246cabbc7d05afc3c/solidity/src/FCL_ecdsa.sol#L40 \n/// @audit 121 chars long\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1) \n/// @audit 124 chars long\n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this \n```\n",
          "loc": [
            "[22](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L22)",
            "[170](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L170)",
            "[213](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L213)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit 125 chars long\n115:     /// @dev Implements encode(domainSeparator : ùîπ¬≤‚Åµ‚Å∂, message : ùïä) = \"\\x19\\x01\" || domainSeparator || hashStruct(message). \n/// @audit 121 chars long\n125:     /// @notice Returns the EIP-712 `hashStruct` result of the `CoinbaseSmartWalletMessage(bytes32 hash)` data structure. \n```\n",
          "loc": [
            "[115](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L115)",
            "[125](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L125)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit 132 chars long\n34:     ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff)) \n```\n",
          "loc": [
            "[34](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L34)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit 125 chars long\n66:     ///           a well-formed assertion with the user present bit set. If `requireUV` is set, checks that the authenticator \n/// @audit 124 chars long\n67:     ///           enforced user verification. User verification should be required if, and only if, options.userVerification\n/// @audit 121 chars long\n69:     ///         - Verifies that the client JSON is of type \"webauthn.get\", i.e. the client was responding to a request to \n/// @audit 126 chars long\n72:     ///         - Verifies that (r, s) constitute a valid signature over both the authenicatorData and client JSON, for public \n/// @audit 126 chars long\n76:     ///         - Does NOT verify that the origin in the `clientDataJSON` matches the Relying Party's origin: tt is considered \n/// @audit 125 chars long\n78:     ///           enforced by most high quality authenticators properly, particularly the iCloud Keychain and Google Password \n/// @audit 128 chars long\n80:     ///         - Does NOT verify That `topOrigin` in `clientDataJSON` is well-formed: We assume it would never be present, i.e. \n/// @audit 121 chars long\n81:     ///           the credentials are never used in a cross-origin/iframe context. The website/app set up should disallow\n/// @audit 130 chars long\n82:     ///           cross-origin usage of the credentials. This is the default behaviour for created credentials in common settings.\n/// @audit 133 chars long\n83:     ///         - Does NOT verify that the `rpIdHash` in `authenticatorData` is the SHA-256 hash of the RP ID expected by the Relying\n/// @audit 136 chars long\n84:     ///           Party: this means that we rely on the authenticator to properly enforce credentials to be used only by the correct RP.\n/// @audit 130 chars long\n85:     ///           This is generally enforced with features like Apple App Site Association and Google Asset Links. To protect from\n/// @audit 129 chars long\n86:     ///           edge cases in which a previously-linked RP ID is removed from the authorised RP IDs, we recommend that messages\n/// @audit 134 chars long\n88:     ///         - Does NOT verify the credential backup state: this assumes the credential backup state is NOT used as part of Relying \n/// @audit 133 chars long\n90:     ///         - Does NOT verify the values of the client extension outputs: this assumes that the Relying Party does not use client \n/// @audit 134 chars long\n92:     ///         - Does NOT verify the signature counter: signature counters are intended to enable risk scoring for the Relying Party. \n/// @audit 134 chars long\n94:     ///         - Does NOT verify the attestation object: this assumes that response.attestationObject is NOT present in the response, \n/// @audit 134 chars long\n137:         // 17. If user verification is required for this assertion, verify that the User Verified bit of the flags in authData is set. \n/// @audit 130 chars long\n147:         // 20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData and hash. \n```\n",
          "loc": [
            "[66](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L66-L67)",
            "[69](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L69)",
            "[72](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L72)",
            "[76](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L76)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L78)",
            "[80](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L80-L86)",
            "[88](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L88)",
            "[90](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L90)",
            "[92](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L92)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L94)",
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L137)",
            "[147](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L147)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Long functions should be refactored into multiple, smaller, functions",
      "description": "Functions with too many lines are difficult to understand. It is recommended to refactor complex functions into multiple shorter and easier to understand functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit 57 lines long\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L104)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Make use of Solidity's `using` keyword",
      "description": "The `using`-`for` [syntax](https://docs.soliditylang.org/en/latest/contracts.html#using-for) is the more common way of calling library functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit SafeTransferLib\n161:             SafeTransferLib.forceSafeTransferETH(account, withdrawable, SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES); \n/// @audit SafeTransferLib\n213:         SafeTransferLib.safeTransferETH(entryPoint(), amount); \n/// @audit SignatureCheckerLib\n265:         return SignatureCheckerLib.isValidSignatureNow( \n266:             owner(), getHash(account, withdrawRequest), withdrawRequest.signature\n267:         );\n/// @audit SignatureCheckerLib\n280:         return SignatureCheckerLib.toEthSignedMessageHash( \n281:             abi.encode(\n282:                 address(this),\n283:                 account,\n284:                 block.chainid,\n285:                 withdrawRequest.asset,\n286:                 withdrawRequest.amount,\n287:                 withdrawRequest.nonce,\n288:                 withdrawRequest.expiry\n289:             )\n290:         );\n/// @audit SafeTransferLib\n336:             SafeTransferLib.safeTransferETH(to, amount); \n/// @audit SafeTransferLib\n338:             SafeTransferLib.safeTransfer(asset, to, amount); \n```\n",
          "loc": [
            "[161](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L161-L161)",
            "[213](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L213-L213)",
            "[265](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L265-L267)",
            "[280](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L280-L290)",
            "[336](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L336-L336)",
            "[338](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L338-L338)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit UserOperationLib\n235:         return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint())); \n/// @audit SignatureCheckerLib\n313:             return SignatureCheckerLib.isValidSignatureNow(owner, message, sigWrapper.signatureData); \n/// @audit WebAuthn\n321:             return WebAuthn.verify({challenge: abi.encode(message), requireUV: false, webAuthnAuth: auth, x: x, y: y}); \n```\n",
          "loc": [
            "[235](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L235-L235)",
            "[313](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L313-L313)",
            "[321](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L321-L321)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit LibClone\n49:             LibClone.createDeterministicERC1967(msg.value, implementation, _getSalt(owners, nonce)); \n/// @audit LibClone\n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this)); \n/// @audit LibClone\n72:         result = LibClone.initCodeHashERC1967(implementation); \n```\n",
          "loc": [
            "[49](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L49-L49)",
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L65-L65)",
            "[72](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L72-L72)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Misplaced SPDX identifier",
      "description": "The SPDX identifier should be on the very first line of each source file.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n1: //curve order (number of points) \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L1)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Missing checks for `address(0x0)` in the constructor",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit _owner missing zero address validation\n101:     constructor(address _owner) { \n```\n",
          "loc": [
            "[101](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L101-L101)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit erc4337 missing zero address validation\n24:     constructor(address erc4337) payable { \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L24-L24)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Missing events in initializers",
      "description": "As a best practice, consider emitting an event when the contract is initialized. In this way, it's easy for the user to track the exact point in time when the contract was initialized, by filtering the emitted events.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n114:     function initialize(bytes[] calldata owners) public payable virtual { \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L114-L114)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Multiple type casts create complexity within the code",
      "description": "To ensure reliable and precise data handling in Solidity contracts, developers should avoid double type casting. Multiple type casts can lead to unintended consequences, such as truncation, rounding errors, or loss of precision. This compromises the contract's functionality and readability, making debugging more challenging. Instead, its crucial to use appropriate data types and minimize unnecessary type casting for a more dependable and robust contract execution.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit uint256(bytes32)\n302:             if (uint256(bytes32(ownerBytes)) > type(uint160).max) { \n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L302-L302)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit uint256(bytes32)\n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n```\n",
          "loc": [
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Contract declarations should have `@author` tags",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n25:  \n26: library FCL {\n27:     //*******************************Constants*******************************************************/\n```\n",
          "loc": [
            "[25](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L25-L27)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Contract declarations should have `@dev` tags",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n25:  \n26: library FCL {\n27:     //*******************************Constants*******************************************************/\n```\n",
          "loc": [
            "[25](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L25-L27)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n19: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol) \n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 {\n21:     /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n```\n",
          "loc": [
            "[19](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L19-L21)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n12: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337Factory.sol) \n13: contract CoinbaseSmartWalletFactory {\n14:     /// @notice Address of the ERC-4337 implementation used as implementation for new accounts.\n```\n",
          "loc": [
            "[12](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L12-L14)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n31: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n32: contract MultiOwnable {\n33:     /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n```\n",
          "loc": [
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L31-L33)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Contract declarations should have `@notice` tags",
      "description": "`@notice` is used to explain to end users what the contract does, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n26: library FCL { \n27:     //*******************************Constants*******************************************************/\n28:     // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo)\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005;\n30:     //curve prime field modulus\n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n32:     //short weierstrass first coefficient\n```\n",
          "loc": [
            "[26](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L26-L32)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Contract declarations should have `@title` tags",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n25:  \n26: library FCL {\n27:     //*******************************Constants*******************************************************/\n```\n",
          "loc": [
            "[25](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L25-L27)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Contract declarations should have NatSpec descriptions",
      "description": "It is recommended that Solidity libraries and contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n26: library FCL { \n27:     //*******************************Constants*******************************************************/\n28:     // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo)\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005;\n30:     //curve prime field modulus\n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n32:     //short weierstrass first coefficient\n```\n",
          "loc": [
            "[26](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L26-L32)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Error missing NatSpec `@dev` tag",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n55:     /// @notice Thrown when trying to use a withdraw request after its expiry has been reched. \n56:     error Expired();\n57: \n60:     /// @param nonce The already used nonce. \n61:     error InvalidNonce(uint256 nonce);\n62: \n67:     /// @param maxCost   The max gas cost required by the Entrypoint. \n68:     error RequestLessThanGasMaxCost(uint256 requested, uint256 maxCost);\n69: \n72:     /// @param asset The requested asset. \n73:     error UnsupportedPaymasterAsset(address asset);\n74: \n79:     /// @param balance         The current contract balance. \n80:     error InsufficientBalance(uint256 requestedAmount, uint256 balance);\n81: \n82:     /// @notice Thrown when trying to withdraw funds but nothing is available.\n83:     error NoExcess();\n84: \n```\n",
          "loc": [
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L55-L57)",
            "[60](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L60-L62)",
            "[67](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L67-L69)",
            "[72](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L72-L74)",
            "[79](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L79-L84)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n45:     /// @notice Thrown when trying to re-initialize an account. \n46:     error Initialized();\n47: \n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L45-L47)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n17:     /// @notice Thrown when trying to create a new `CoinbaseSmartWallet` account without any owner. \n18:     error OwnerRequired();\n19: \n```\n",
          "loc": [
            "[17](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L17-L19)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n39:     /// @notice Thrown when the sender is not an owner and is trying to call a privileged function. \n40:     error Unauthorized();\n41: \n44:     /// @param owner The raw abi encoded owner bytes. \n45:     error AlreadyOwner(bytes owner);\n46: \n49:     /// @param index The targeted index for removal. \n50:     error NoOwnerAtIndex(uint256 index);\n51: \n55:     /// @param owner The invalid raw abi encoded owner bytes. \n56:     error InvalidOwnerBytesLength(bytes owner);\n57: \n61:     /// @param owner The invalid raw abi encoded owner bytes. \n62:     error InvalidEthereumAddressOwner(bytes owner);\n63: \n```\n",
          "loc": [
            "[39](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L39-L41)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L44-L46)",
            "[49](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L49-L51)",
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L55-L57)",
            "[61](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L61-L63)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Error missing NatSpec `@param` tag",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit Missing @param for `maxCost`\n68:     error RequestLessThanGasMaxCost(uint256 requested, uint256 maxCost); \n/// @audit Missing @param for `requestedAmount`\n80:     error InsufficientBalance(uint256 requestedAmount, uint256 balance); \n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L68-L68)",
            "[80](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L80-L80)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Event missing NatSpec `@dev` tag",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n44:     /// @param nonce   The request nonce. \n45:     event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce);\n46: \n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L44-L46)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n67:     /// @param owner The raw abi encoded owner bytes. \n68:     event AddOwner(uint256 indexed index, bytes owner);\n69: \n73:     /// @param owner The raw abi encoded owner bytes. \n74:     event RemoveOwner(uint256 indexed index, bytes owner);\n75: \n```\n",
          "loc": [
            "[67](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L67-L69)",
            "[73](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L73-L75)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: File is missing NatSpec Documentation",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n1: //curve order (number of points) \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L1)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Function declarations should have `@notice` tags",
      "description": "`@notice` is used to explain to end users what the function does, and the compiler interprets `///` or `/**` comments as this tag if one was't explicitly provided",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L78)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L293)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n252:     function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) { \n```\n",
          "loc": [
            "[252](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L252-L252)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n121:     function _eip712Hash(bytes32 hash) internal view virtual returns (bytes32) { \n```\n",
          "loc": [
            "[121](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L121-L121)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Function declarations should have NatSpec descriptions",
      "description": "It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Functions missing NatSpec `@dev` tag",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n49:  \n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) {\n51:         if (r == 0 || r >= n || s == 0 || s >= n) {\n93:      */ \n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) {\n95:         assembly {\n273:  \n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) {\n275:         uint256 zz0;\n```\n",
          "loc": [
            "[49](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L49-L51)",
            "[93](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L93-L95)",
            "[273](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L273-L275)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n100:     /// @param _owner The initial owner of this contract. \n101:     constructor(address _owner) {\n102:         Ownable._initializeOwner(_owner);\n105:     /// @notice Receive function allowing ETH to be deposited in this contract. \n106:     receive() external payable {}\n107: \n108:     /// @inheritdoc IPaymaster\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n110:         external\n142:     /// @inheritdoc IPaymaster \n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n144:         external\n180:     /// @param withdrawRequest The withdraw request. \n181:     function withdraw(WithdrawRequest memory withdrawRequest) external {\n182:         _validateRequest(msg.sender, withdrawRequest);\n298:     /// @return `true` if the nonce has already been used by the account, else `false`. \n299:     function nonceUsed(address account, uint256 nonce) external view returns (bool) {\n300:         return _nonceUsed[nonce][account];\n303:     /// @notice Returns the canonical ERC-4337 EntryPoint v0.6 contract. \n304:     function entryPoint() public pure returns (address) {\n305:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n```\n",
          "loc": [
            "[100](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L100-L102)",
            "[105](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L105-L110)",
            "[142](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L142-L144)",
            "[180](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L180-L182)",
            "[298](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L298-L300)",
            "[303](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L303-L305)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n101:  \n102:     constructor() {\n103:         // Implementation should not be initializable (does not affect proxies which use their own storage).\n216:     /// @return The address of the EntryPoint v0.6 \n217:     function entryPoint() public view virtual returns (address) {\n218:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n240:     /// @return $ The address of implementation contract. \n241:     function implementation() public view returns (address $) {\n242:         assembly {\n251:     /// @return `true` is the function selector is whitelisted to skip the chain ID validation, else `false`. \n252:     function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) {\n253:         if (\n332:     /// @inheritdoc ERC1271 \n333:     function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) {\n334:         return (\"Coinbase Smart Wallet\", \"1\");\n```\n",
          "loc": [
            "[101](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L101-L103)",
            "[216](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L216-L218)",
            "[240](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L240-L242)",
            "[251](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L251-L253)",
            "[332](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L332-L334)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n23:     /// @param erc4337 The address of the ERC-4337 implementation used to deploy new cloned accounts. \n24:     constructor(address erc4337) payable {\n25:         implementation = erc4337;\n63:     /// @return predicted The predicted account deployment address. \n64:     function getAddress(bytes[] calldata owners, uint256 nonce) external view returns (address predicted) {\n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this));\n70:     /// @return result The initialization code hash. \n71:     function initCodeHash() public view virtual returns (bytes32 result) {\n72:         result = LibClone.initCodeHashERC1967(implementation);\n80:     /// @return salt The computed salt. \n81:     function _getSalt(bytes[] calldata owners, uint256 nonce) internal pure returns (bytes32 salt) {\n82:         salt = keccak256(abi.encode(owners, nonce));\n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L23-L25)",
            "[63](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L63-L65)",
            "[70](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L70-L72)",
            "[80](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L80-L82)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n120:     /// @return The resulting EIP-712 hash. \n121:     function _eip712Hash(bytes32 hash) internal view virtual returns (bytes32) {\n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash)));\n```\n",
          "loc": [
            "[120](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L120-L122)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n84:     /// @param owner The owner address. \n85:     function addOwnerAddress(address owner) public virtual onlyOwner {\n86:         _addOwner(abi.encode(owner));\n92:     /// @param y The owner public key y coordinate. \n93:     function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner {\n94:         _addOwner(abi.encode(x, y));\n116:     /// @return `true` if the account is an owner, else `false`. \n117:     function isOwnerAddress(address account) public view virtual returns (bool) {\n118:         return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n126:     /// @return `true` if the account is an owner, else `false`. \n127:     function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) {\n128:         return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n135:     /// @return `true` if the account is an owner, else `false`. \n136:     function isOwnerBytes(bytes memory account) public view virtual returns (bool) {\n137:         return _getMultiOwnableStorage().isOwner[account];\n144:     /// @return The owner bytes (empty if no owner is registered at this `index`). \n145:     function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) {\n146:         return _getMultiOwnableStorage().ownerAtIndex[index];\n151:     /// @return The next index that will be used to add a new owner. \n152:     function nextOwnerIndex() public view virtual returns (uint256) {\n153:         return _getMultiOwnableStorage().nextOwnerIndex;\n178:     /// @param owner The owner raw bytes to add. \n179:     function _addOwner(bytes memory owner) internal virtual {\n180:         _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n211:     /// @return $ A storage reference to the `MultiOwnableStorage` struct. \n212:     function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) {\n213:         assembly (\"memory-safe\") {\n```\n",
          "loc": [
            "[84](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L84-L86)",
            "[92](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L92-L94)",
            "[116](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L116-L118)",
            "[126](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L126-L128)",
            "[135](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L135-L137)",
            "[144](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L144-L146)",
            "[151](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L151-L153)",
            "[178](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L178-L180)",
            "[211](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L211-L213)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Functions missing NatSpec `@param` tag",
      "description": "It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Missing @param for all function parameters\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n/// @audit Missing @param for all function parameters\n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n/// @audit Missing @param for all function parameters\n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n/// @audit Missing @param for all function parameters\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n/// @audit Missing @param for all function parameters\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n/// @audit Missing @param for all function parameters\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n/// @audit Missing @param for all function parameters\n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n302:         internal\n303:         view\n304:         returns (uint256 x1, uint256 y1)\n305:     {\n/// @audit Missing @param for all function parameters\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n/// @audit Missing @param for all function parameters\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n/// @audit Missing @param for all function parameters\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L78)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L94)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L122)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L293)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L305)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L322)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L348)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L374)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit Missing @param for all function parameters\n181:     function withdraw(WithdrawRequest memory withdrawRequest) external { \n/// @audit Missing @param for `unstakeDelaySeconds`\n232:     function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner { \n/// @audit Missing @param for `withdrawRequest`\n260:     function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest) \n261:         public\n262:         view\n263:         returns (bool)\n264:     {\n/// @audit Missing @param for `withdrawRequest`\n279:     function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) { \n/// @audit Missing @param for `withdrawRequest`\n315:     function _validateRequest(address account, WithdrawRequest memory withdrawRequest) internal { \n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L181-L181)",
            "[232](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L232-L232)",
            "[260](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L260-L264)",
            "[279](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L279-L279)",
            "[315](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L315-L315)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Missing @param for all function parameters\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n/// @audit Missing @param for all function parameters\n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n/// @audit Missing @param for all function parameters\n252:     function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) { \n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L144)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L234)",
            "[252](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L252-L252)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit Missing @param for all function parameters\n121:     function _eip712Hash(bytes32 hash) internal view virtual returns (bytes32) { \n```\n",
          "loc": [
            "[121](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L121-L121)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit Missing @param for `requireUV`, `webAuthnAuth`\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n105:         internal\n106:         view\n107:         returns (bool)\n108:     {\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L108)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Functions missing NatSpec `@return` tag",
      "description": "It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Missing @return for all function parameters\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n/// @audit Missing @return for all function parameters\n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n/// @audit Missing @return for all function parameters\n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n/// @audit Missing @return for all function parameters\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n/// @audit Missing @return for all function parameters\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n/// @audit Missing @return for all function parameters\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n/// @audit Missing @return for all function parameters\n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n302:         internal\n303:         view\n304:         returns (uint256 x1, uint256 y1)\n305:     {\n/// @audit Missing @return for all function parameters\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n/// @audit Missing @return for all function parameters\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n/// @audit Missing @return for all function parameters\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L78)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L94)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L122)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L293)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L305)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L322)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L348)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L374)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit Missing @return for all function parameters\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n/// @audit Missing @return for all function parameters\n304:     function entryPoint() public pure returns (address) { \n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L113)",
            "[304](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L304-L304)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Missing @return for all function parameters\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n/// @audit Missing @return for all function parameters\n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n/// @audit Missing @return for all function parameters\n291:     function _validateSignature(bytes32 message, bytes calldata signature) \n292:         internal\n293:         view\n294:         virtual\n295:         override\n296:         returns (bool)\n297:     {\n/// @audit Missing @return for all function parameters\n333:     function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) { \n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L144)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L234)",
            "[291](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L291-L297)",
            "[333](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L333-L333)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit Missing @return for all function parameters\n38:     function createAccount(bytes[] calldata owners, uint256 nonce) \n39:         public\n40:         payable\n41:         virtual\n42:         returns (CoinbaseSmartWallet account)\n43:     {\n```\n",
          "loc": [
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L38-L43)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit Missing @return for `chainId`, `verifyingContract`\n36:     function eip712Domain() \n37:         external\n38:         view\n39:         virtual\n40:         returns (\n41:             bytes1 fields,\n42:             string memory name,\n43:             string memory version,\n44:             uint256 chainId,\n45:             address verifyingContract,\n46:             bytes32 salt,\n47:             uint256[] memory extensions\n48:         )\n49:     {\n```\n",
          "loc": [
            "[36](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L36-L49)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Modifier missing NatSpec `@dev` tag",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n64:     /// @notice Reverts if the caller is not the EntryPoint. \n65:     modifier onlyEntryPoint() virtual {\n66:         if (msg.sender != entryPoint()) {\n73:     /// @notice Reverts if the caller is neither the EntryPoint, the owner, nor the account itself. \n74:     modifier onlyEntryPointOrOwner() virtual {\n75:         if (msg.sender != entryPoint()) {\n```\n",
          "loc": [
            "[64](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L64-L66)",
            "[73](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L73-L75)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n76:     /// @notice Access control modifier ensuring the caller is an authorized owner \n77:     modifier onlyOwner() virtual {\n78:         _checkOwner();\n```\n",
          "loc": [
            "[76](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L76-L78)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "NatSpec: Modifier missing NatSpec `@param` tag",
      "description": "It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation. In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Missing @param for all modifier parameters\n91:     modifier payPrefund(uint256 missingAccountFunds) virtual { \n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L91-L91)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Natspec: Use `@inheritdoc` rather than using a non-standard tags",
      "description": "Using non-standard annotations like `@dev see Ellipsis` can lead to inconsistencies and lack of clarity in your smart contract documentation. It's recommended to use the `@inheritdoc` annotation for enhanced clarity and uniformity in smart contract development.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n11: /// @title Magic Spend \n12: ///\n13: /// @author Coinbase (https://github.com/coinbase/magic-spend)\n14: ///\n15: /// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6.\n```\n",
          "loc": [
            "[11](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L11-L15)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n125:     /// @notice Returns the EIP-712 `hashStruct` result of the `CoinbaseSmartWalletMessage(bytes32 hash)` data structure. \n126:     ///\n127:     /// @dev Implements hashStruct(s : ùïä) = keccak256(typeHash || encodeData(s)).\n128:     /// @dev See https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n```\n",
          "loc": [
            "[125](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L125-L128)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Non-`external`/`public` function names should begin with an underscore",
      "description": "According to the Solidity Style Guide, Non-`external`/`public` function names should begin with an <a href=\"https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables\">underscore</a>.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit _ecdsa_verify\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n51:         if (r == 0 || r >= n || s == 0 || s >= n) {\n52:             return false;\n53:         }\n54: \n55:         if (!ecAff_isOnCurve(Qx, Qy)) {\n56:             return false;\n57:         }\n58: \n59:         uint256 sInv = FCL_nModInv(s);\n60: \n61:         uint256 scalar_u = mulmod(uint256(message), sInv, n);\n62:         uint256 scalar_v = mulmod(r, sInv, n);\n63:         uint256 x1;\n64: \n65:         x1 = ecZZ_mulmuladd_S_asm(Qx, Qy, scalar_u, scalar_v);\n66: \n67:         x1 = addmod(x1, n - r, n);\n68: \n69:         return x1 == 0;\n70:     }\n/// @audit _ecAff_isOnCurve\n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n79:         if (((0 == x) && (0 == y)) || x == p || y == p) {\n80:             return false;\n81:         }\n82:         unchecked {\n83:             uint256 LHS = mulmod(y, y, p); // y^2\n84:             uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(x, a, p), p); // x^3+ax\n85:             RHS = addmod(RHS, b, p); // x^3 + a*x + b\n86: \n87:             return LHS == RHS;\n88:         }\n89:     }\n/// @audit _FCL_nModInv\n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n95:         assembly {\n96:             let pointer := mload(0x40)\n97:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n98:             mstore(pointer, 0x20)\n99:             mstore(add(pointer, 0x20), 0x20)\n100:             mstore(add(pointer, 0x40), 0x20)\n101:             // Define variables base, exponent and modulus\n102:             mstore(add(pointer, 0x60), u)\n103:             mstore(add(pointer, 0x80), minus_2modn)\n104:             mstore(add(pointer, 0xa0), n)\n105: \n106:             // Call the precompiled contract 0x05 = ModExp\n107:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n108:             result := mload(pointer)\n109:         }\n110:     }\n/// @audit _ecZZ_mulmuladd_S_asm\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n123:         uint256 zz;\n124:         uint256 zzz;\n125:         uint256 Y;\n126:         uint256 index = 255;\n127:         uint256 H0;\n128:         uint256 H1;\n129: \n130:         unchecked {\n131:             if (scalar_u == 0 && scalar_v == 0) return 0;\n132: \n133:             (H0, H1) = ecAff_add(gx, gy, Q0, Q1);\n134:             if (\n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n136:             ) {\n137:                 scalar_u = addmod(scalar_u, n - scalar_v, n);\n138:                 scalar_v = 0;\n139:             }\n140:             assembly {\n141:                 for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n142:                     index := sub(index, 1)\n143:                     T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n144:                 } {}\n145:                 zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n146: \n147:                 if eq(zz, 1) {\n148:                     X := gx\n149:                     Y := gy\n150:                 }\n151:                 if eq(zz, 2) {\n152:                     X := Q0\n153:                     Y := Q1\n154:                 }\n155:                 if eq(zz, 3) {\n156:                     X := H0\n157:                     Y := H1\n158:                 }\n159: \n160:                 index := sub(index, 1)\n161:                 zz := 1\n162:                 zzz := 1\n163: \n164:                 for {} gt(minus_1, index) { index := sub(index, 1) } {\n165:                     // inlined EcZZ_Dbl\n166:                     let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n167:                     let T2 := mulmod(T1, T1, p) // V=U^2\n168:                     let T3 := mulmod(X, T2, p) // S = X1*V\n169:                     T1 := mulmod(T1, T2, p) // W=UV\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n173: \n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n177: \n178:                     {\n179:                         //value of dibit\n180:                         T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n181: \n182:                         if iszero(T4) {\n183:                             Y := sub(p, Y) //restore the -Y inversion\n184:                             continue\n185:                         } // if T4!=0\n186: \n187:                         if eq(T4, 1) {\n188:                             T1 := gx\n189:                             T2 := gy\n190:                         }\n191:                         if eq(T4, 2) {\n192:                             T1 := Q0\n193:                             T2 := Q1\n194:                         }\n195:                         if eq(T4, 3) {\n196:                             T1 := H0\n197:                             T2 := H1\n198:                         }\n199:                         if iszero(zz) {\n200:                             X := T1\n201:                             Y := T2\n202:                             zz := 1\n203:                             zzz := 1\n204:                             continue\n205:                         }\n206:                         // inlined EcZZ_AddN\n207: \n208:                         //T3:=sub(p, Y)\n209:                         //T3:=Y\n210:                         let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n212: \n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n214:                         //todo : construct edge vector case\n215:                         if iszero(y2) {\n216:                             if iszero(T2) {\n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n220: \n221:                                 T1 := mulmod(T1, T2, p) // W=UV\n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n224: \n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n227: \n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n230: \n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n232: \n233:                                 continue\n234:                             }\n235:                         }\n236: \n237:                         T4 := mulmod(T2, T2, p) //PP\n238:                         let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n239:                         zz := mulmod(zz, T4, p)\n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n241:                         let TT2 := mulmod(X, T4, p)\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n244: \n245:                         X := T4\n246:                     }\n247:                 } //end loop\n248:                 let T := mload(0x40)\n249:                 mstore(add(T, 0x60), zz)\n250:                 //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n251:                 //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n252:                 // Define length of base, exponent and modulus. 0x20 == 32 bytes\n253:                 mstore(T, 0x20)\n254:                 mstore(add(T, 0x20), 0x20)\n255:                 mstore(add(T, 0x40), 0x20)\n256:                 // Define variables base, exponent and modulus\n257:                 //mstore(add(pointer, 0x60), u)\n258:                 mstore(add(T, 0x80), minus_2)\n259:                 mstore(add(T, 0xa0), p)\n260: \n261:                 // Call the precompiled contract 0x05 = ModExp\n262:                 if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n263: \n264:                 //Y:=mulmod(Y,zzz,p)//Y/zzz\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z\n266:                 //zz:= mulmod(zz,zz,p) //1/zz\n267:                 X := mulmod(X, mload(T), p) //X/zz\n268:             } //end assembly\n269:         } //end unchecked\n270: \n271:         return X;\n272:     }\n/// @audit _ecAff_add\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n275:         uint256 zz0;\n276:         uint256 zzz0;\n277: \n278:         if (ecAff_IsZero(x0, y0)) return (x1, y1);\n279:         if (ecAff_IsZero(x1, y1)) return (x0, y0);\n280:         if ((x0 == x1) && (y0 == y1)) {\n281:             (x0, y0, zz0, zzz0) = ecZZ_Dbl(x0, y0, 1, 1);\n282:         } else {\n283:             (x0, y0, zz0, zzz0) = ecZZ_AddN(x0, y0, 1, 1, x1, y1);\n284:         }\n285: \n286:         return ecZZ_SetAff(x0, y0, zz0, zzz0);\n287:     }\n/// @audit _ecAff_IsZero\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n294:         return (y == 0);\n295:     }\n/// @audit _ecZZ_SetAff\n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n302:         internal\n303:         view\n304:         returns (uint256 x1, uint256 y1)\n305:     {\n306:         uint256 zzzInv = FCL_pModInv(zzz); //1/zzz\n307:         y1 = mulmod(y, zzzInv, p); //Y/zzz\n308:         uint256 _b = mulmod(zz, zzzInv, p); //1/z\n309:         zzzInv = mulmod(_b, _b, p); //1/zz\n310:         x1 = mulmod(x, zzzInv, p); //X/zz\n311:     }\n/// @audit _ecZZ_Dbl\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n323:         unchecked {\n324:             assembly {\n325:                 P0 := mulmod(2, y, p) //U = 2*Y1\n326:                 P2 := mulmod(P0, P0, p) // V=U^2\n327:                 P3 := mulmod(x, P2, p) // S = X1*V\n328:                 P1 := mulmod(P0, P2, p) // W=UV\n329:                 P2 := mulmod(P2, zz, p) //zz3=V*ZZ1\n330:                 zz := mulmod(3, mulmod(addmod(x, sub(p, zz), p), addmod(x, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n331:                 P0 := addmod(mulmod(zz, zz, p), mulmod(minus_2, P3, p), p) //X3=M^2-2S\n332:                 x := mulmod(zz, addmod(P3, sub(p, P0), p), p) //M(S-X3)\n333:                 P3 := mulmod(P1, zzz, p) //zzz3=W*zzz1\n334:                 P1 := addmod(x, sub(p, mulmod(P1, y, p)), p) //Y3= M(S-X3)-W*Y1\n335:             }\n336:         }\n337:         return (P0, P1, P2, P3);\n338:     }\n/// @audit _ecZZ_AddN\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n349:         unchecked {\n350:             if (y1 == 0) {\n351:                 return (x2, y2, 1, 1);\n352:             }\n353: \n354:             assembly {\n355:                 y1 := sub(p, y1)\n356:                 y2 := addmod(mulmod(y2, zzz1, p), y1, p)\n357:                 x2 := addmod(mulmod(x2, zz1, p), sub(p, x1), p)\n358:                 P0 := mulmod(x2, x2, p) //PP = P^2\n359:                 P1 := mulmod(P0, x2, p) //PPP = P*PP\n360:                 P2 := mulmod(zz1, P0, p) ////ZZ3 = ZZ1*PP\n361:                 P3 := mulmod(zzz1, P1, p) ////ZZZ3 = ZZZ1*PPP\n362:                 zz1 := mulmod(x1, P0, p) //Q = X1*PP\n363:                 P0 := addmod(addmod(mulmod(y2, y2, p), sub(p, P1), p), mulmod(minus_2, zz1, p), p) //R^2-PPP-2*Q\n364:                 P1 := addmod(mulmod(addmod(zz1, sub(p, P0), p), y2, p), mulmod(y1, P1, p), p) //R*(Q-X3)\n365:             }\n366:             //end assembly\n367:         } //end unchecked\n368:         return (P0, P1, P2, P3);\n369:     }\n/// @audit _FCL_pModInv\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n375:         assembly {\n376:             let pointer := mload(0x40)\n377:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n378:             mstore(pointer, 0x20)\n379:             mstore(add(pointer, 0x20), 0x20)\n380:             mstore(add(pointer, 0x40), 0x20)\n381:             // Define variables base, exponent and modulus\n382:             mstore(add(pointer, 0x60), u)\n383:             mstore(add(pointer, 0x80), minus_2)\n384:             mstore(add(pointer, 0xa0), p)\n385: \n386:             // Call the precompiled contract 0x05 = ModExp\n387:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n388:             result := mload(pointer)\n389:         }\n390:     }\n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L70)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L89)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L110)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L272)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L287)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L295)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L311)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L338)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L369)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L390)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit _verify\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n105:         internal\n106:         view\n107:         returns (bool)\n108:     {\n109:         if (webAuthnAuth.s > P256_N_DIV_2) {\n110:             // guard against signature malleability\n111:             return false;\n112:         }\n113: \n114:         // 11. Verify that the value of C.type is the string webauthn.get.\n115:         // bytes(\"type\":\"webauthn.get\").length = 21\n116:         string memory _type = webAuthnAuth.clientDataJSON.slice(webAuthnAuth.typeIndex, webAuthnAuth.typeIndex + 21);\n117:         if (keccak256(bytes(_type)) != EXPECTED_TYPE_HASH) {\n118:             return false;\n119:         }\n120: \n121:         // 12. Verify that the value of C.challenge equals the base64url encoding of options.challenge.\n122:         bytes memory expectedChallenge = bytes(string.concat('\"challenge\":\"', Base64.encodeURL(challenge), '\"'));\n123:         string memory actualChallenge = webAuthnAuth.clientDataJSON.slice(\n124:             webAuthnAuth.challengeIndex, webAuthnAuth.challengeIndex + expectedChallenge.length\n125:         );\n126:         if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) {\n127:             return false;\n128:         }\n129: \n130:         // Skip 13., 14., 15.\n131: \n132:         // 16. Verify that the UP bit of the flags in authData is set.\n133:         if (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UP != AUTH_DATA_FLAGS_UP) {\n134:             return false;\n135:         }\n136: \n137:         // 17. If user verification is required for this assertion, verify that the User Verified bit of the flags in authData is set.\n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) {\n139:             return false;\n140:         }\n141: \n142:         // skip 18.\n143: \n144:         // 19. Let hash be the result of computing a hash over the cData using SHA-256.\n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON));\n146: \n147:         // 20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData and hash.\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash));\n149:         bytes memory args = abi.encode(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n150:         // try the RIP-7212 precompile address\n151:         (bool success, bytes memory ret) = VERIFIER.staticcall(args);\n152:         // staticcall will not revert if address has no code\n153:         // check return length\n154:         // note that even if precompile exists, ret.length is 0 when verification returns false\n155:         // so an invalid signature will be checked twice: once by the precompile and once by FCL.\n156:         // Ideally this signature failure is simulated offchain and no one actually pay this gas.\n157:         bool valid = ret.length > 0;\n158:         if (success && valid) return abi.decode(ret, (uint256)) == 1;\n159: \n160:         return FCL.ecdsa_verify(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n161:     }\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L161)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Non-library/interface files should use fixed compiler versions, not floating ones",
      "description": "To prevent the actual contracts being deployed from behaving differently depending on the compiler version, it is recommended to use fixed solidity versions for contracts and libraries.\n\nAlthough we can configure a specific version through config (like hardhat, forge config files), it is recommended to **set the fixed version in the solidity pragma directly** before deploying to the mainnet.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Not using the latest versions of project dependencies",
      "description": "Update the project dependencies to their latest versions wherever possible.\n\nUse tools such as `retire.js`, `npm audit`, and `yarn audit` to confirm that no vulnerable dependencies remain.\n\n|Dependency|Current Version|Latest Version|\n|:-:|:-:|:-:|\n|`forge-std`|1.7.6|1.8.0|\n|`solady`|0.0.177|0.0.168|\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L1)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Not using the named return variables anywhere in the function is confusing",
      "description": "Declaring named returns, but not using them, is confusing to the reader. Consider either completely removing them (by declaring just the type without a name), or remove the return statement and do a variable assignment.\n\nThis would improve the readability of the code, and it may also help reduce regressions during future code refactors.\n\nIf the optimizer is not turned on, leaving the code as it is will also waste gas for the stack variable.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit flag is unused\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n294:         return (y == 0);\n295:     }\n```\n",
          "loc": [
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L295)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit validationData is unused\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n145:         uint256 key = userOp.nonce >> 64;\n146: \n147:         // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n149:             userOpHash = getUserOpHashWithoutChainId(userOp);\n150:             if (key != REPLAYABLE_NONCE_KEY) {\n151:                 revert InvalidNonceKey(key);\n152:             }\n153:         } else {\n154:             if (key == REPLAYABLE_NONCE_KEY) {\n155:                 revert InvalidNonceKey(key);\n156:             }\n157:         }\n158: \n159:         // Return 0 if the recovered address matches the owner.\n160:         if (_validateSignature(userOpHash, userOp.signature)) {\n161:             return 0;\n162:         }\n163: \n164:         // Else return 1, which is equivalent to:\n165:         // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n166:         // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n167:         return 1;\n168:     }\n/// @audit userOpHash is unused\n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n235:         return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint()));\n236:     }\n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L168)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L236)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit result is unused\n69:     function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4 result) { \n70:         if (_validateSignature({message: replaySafeHash(hash), signature: signature})) {\n71:             // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n72:             return 0x1626ba7e;\n73:         }\n74: \n75:         return 0xffffffff;\n76:     }\n/// @audit name is unused\n/// @audit version is unused\n143:     function _domainNameAndVersion() internal view virtual returns (string memory name, string memory version); \n```\n",
          "loc": [
            "[69](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L69-L76)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L143-L143)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit $ is unused\n212:     function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) { \n213:         assembly (\"memory-safe\") {\n214:             $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n215:         }\n216:     }\n```\n",
          "loc": [
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L212-L216)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Outdated Solidity version",
      "description": "Upgrade to the latest solidity version.\n\n<a href=\"https://blog.soliditylang.org/2021/04/21/solidity-0.8.4-release-announcement/\">0.8.4</a>: bytes.concat() instead of abi.encodePacked(<bytes>,<bytes>) \n<a href=\"https://blog.soliditylang.org/2022/02/16/solidity-0.8.12-release-announcement/\">0.8.12</a>: string.concat() instead of abi.encodePacked(<str>,<str>) \n<a href=\"https://blog.soliditylang.org/2022/03/16/solidity-0.8.13-release-announcement/\">0.8.13</a>:\n- Ability to use using for with a list of free functions\n\n<a href=\"https://blog.soliditylang.org/2022/05/18/solidity-0.8.14-release-announcement/\">0.8.14</a>:\n- ABI Encoder: When ABI-encoding values from calldata that contain nested arrays, correctly validate the nested array length against calldatasize() in all cases.\n- Override Checker: Allow changing data location for parameters only when overriding external functions.\n\n<a href=\"https://blog.soliditylang.org/2022/06/15/solidity-0.8.15-release-announcement/\">0.8.15</a>:\n- Code Generation: Avoid writing dirty bytes to storage when copying bytes arrays.\n- Yul Optimizer: Keep all memory side-effects of inline assembly blocks.\n\n<a href=\"https://blog.soliditylang.org/2022/08/08/solidity-0.8.16-release-announcement/\">0.8.16</a>:\n - Code Generation: Fix data corruption that affected ABI-encoding of calldata values represented by tuples: structs at any nesting level; argument lists of external functions, events and errors; return value lists of external functions. The 32 leading bytes of the first dynamically-encoded value in the tuple would get zeroed when the last component contained a statically-encoded array.\n\n<a href=\"https://blog.soliditylang.org/2022/09/08/solidity-0.8.17-release-announcement/\">0.8.17</a>:\n - Yul Optimizer: Prevent the incorrect removal of storage writes before calls to Yul functions that conditionally terminate the external EVM call.\n\n<a href=\"https://blog.soliditylang.org/2023/02/22/solidity-0.8.19-release-announcement/\">0.8.19</a>:\n- SMTChecker: New trusted mode that assumes that any compile-time available code is the actual used code, even in external calls.\n\nBug Fixes:\n- Assembler: Avoid duplicating subassembly bytecode where possible.\n- Code Generator: Avoid including references to the deployed label of referenced functions if they are called right away.\n- ContractLevelChecker: Properly distinguish the case of missing base constructor arguments from having an unimplemented base function.\n- SMTChecker: Fix internal error caused by unhandled z3 expressions that come from the solver when bitwise operators are used.\n- SMTChecker: Fix internal error when using the custom NatSpec annotation to abstract free functions.\n- TypeChecker: Also allow external library functions in using for.\n\n<a href=\"https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/\">0.8.20</a>:\n- Assembler: Use push0 for placing 0 on the stack for EVM versions starting from ‚ÄúShanghai‚Äù. This decreases the deployment and runtime costs.\n- Optimizer: Re-implement simplified version of UnusedAssignEliminator and UnusedStoreEliminator. It can correctly remove some unused assignments in deeply nested loops that were ignored by the old version.\n- Parser: Unary plus is no longer recognized as a unary operator in the AST and triggers an error at the parsing stage (rather than later during the analysis).\n- SMTChecker: Group all messages about unsupported language features in a single warning. The CLI option --model-checker-show-unsupported and the JSON option settings.modelChecker.showUnsupported can be enabled to show the full list.\n- SMTChecker: Properties that are proved safe are now reported explicitly at the end of analysis. By default, only the number of safe properties is shown. The CLI option --model-checker-show-proved-safe and the JSON option settings.modelChecker.showProvedSafe can be enabled to show the full list of safe properties.\n- Standard JSON Interface: Add experimental support for importing ASTs via Standard JSON.\n- Yul EVM Code Transform: If available, use push0 instead of codesize to produce an arbitrary value on stack in order to create equal stack heights between branches.\n\n<a href=\"https://soliditylang.org/blog/2023/07/19/solidity-0.8.21-release-announcement\">0.8.21</a>:\n- Code Generator: Always generate code for the expression in `<expression>.selector` in the legacy code generation pipeline.\n- Yul Optimizer: Fix FullInliner step (i) not preserving the evaluation order of arguments passed into inlined functions in code that is not in expression-split form.\n- Allow qualified access to events from other contracts.\n- Relax restrictions on initialization of immutable variables. Reads and writes may now happen at any point at construction time outside of functions and modifiers. Explicit initialization is no longer mandatory.\n",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n24: pragma solidity >=0.8.19 <0.9.0; \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L24)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n2: pragma solidity 0.8.23; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n2: pragma solidity 0.8.23; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n2: pragma solidity ^0.8.0; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L2)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Parameter change does not emit event",
      "description": "Events help non-contract tools to track changes",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n85:     function addOwnerAddress(address owner) public virtual onlyOwner { \n86:         _addOwner(abi.encode(owner));\n87:     }\n179:     function _addOwner(bytes memory owner) internal virtual { \n180:         _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++);\n181:     }\n```\n",
          "loc": [
            "[85](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L85-L87)",
            "[179](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L179-L181)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Prefer skip over revert model in iteration",
      "description": "It is preferable to skip operations on an array index when a condition is not met rather than reverting the whole transaction as reverting can introduce the possiblity of malicous actors purposefully introducing array objects which fail conditional checks within for/while loops so group operations fail. As such it is recommended to simply skip such array indices over reverting unless there is a valid security or logic reason behind not doing so.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit reverts on line: 165, 169\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`public` functions not called by the contract should be declared `external` instead",
      "description": "Contracts are allowed to override their parents‚Äô functions and change the visibility from public to external.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n114:     function initialize(bytes[] calldata owners) public payable virtual { \n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n180:     function executeWithoutChainIdValidation(bytes calldata data) public payable virtual onlyEntryPoint { \n196:     function execute(address target, uint256 value, bytes calldata data) public payable virtual onlyEntryPointOrOwner { \n205:     function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner { \n241:     function implementation() public view returns (address $) { \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L114)",
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137)",
            "[180](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L180)",
            "[196](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L196)",
            "[205](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L205)",
            "[241](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L241)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n38:     function createAccount(bytes[] calldata owners, uint256 nonce) \n```\n",
          "loc": [
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L38)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n69:     function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4 result) { \n```\n",
          "loc": [
            "[69](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L69)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n85:     function addOwnerAddress(address owner) public virtual onlyOwner { \n93:     function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner { \n102:     function removeOwnerAtIndex(uint256 index) public virtual onlyOwner { \n127:     function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) { \n152:     function nextOwnerIndex() public view virtual returns (uint256) { \n```\n",
          "loc": [
            "[85](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L85)",
            "[93](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L93)",
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L102)",
            "[127](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L127)",
            "[152](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L152)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "`receive()`/`payable fallback()` function does not authorize requests",
      "description": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n106:     receive() external payable {} \n```\n",
          "loc": [
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L106-L106)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Returning a struct instead of a bunch of variables is better",
      "description": "If a function returns [too many variables](https://docs.soliditylang.org/en/v0.8.21/contracts.html#returning-multiple-values), replacing them with a struct can improve code readability, maintainability and reusability.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n```\n",
          "loc": [
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L322)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L348)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n36:     function eip712Domain() \n37:         external\n38:         view\n39:         virtual\n40:         returns (\n41:             bytes1 fields,\n42:             string memory name,\n43:             string memory version,\n44:             uint256 chainId,\n45:             address verifyingContract,\n46:             bytes32 salt,\n47:             uint256[] memory extensions\n48:         )\n49:     {\n```\n",
          "loc": [
            "[36](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L36-L49)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Some variables have a implicit default visibility",
      "description": "Consider always adding an explicit visibility modifier for variables, as the default is `internal`.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005; \n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF; \n33:     uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC; \n35:     uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B; \n37:     uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296; \n38:     uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n40:     uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551; \n42:     uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD; \n44:     uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F; \n46:     uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \n```\n",
          "loc": [
            "[29](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L29)",
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L31)",
            "[33](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L33)",
            "[35](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L35)",
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L37-L38)",
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L40)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L42)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L44)",
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L46)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "State variables should include comments",
      "description": "Consider adding some comments on critical state variables to explain what they are supposed to do: this will help for future code reviews.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n38:     uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5; \n46:     uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \n```\n",
          "loc": [
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L38-L38)",
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L46-L46)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Top-level declarations should be separated by at least two lines",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n26: library FCL { \n27:     //*******************************Constants*******************************************************/\n28:     // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo)\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005;\n272:     } \n273: \n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) {\n```\n",
          "loc": [
            "[26](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L26-L29)",
            "[272](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L272-L274)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n18: contract MagicSpend is Ownable, IPaymaster { \n19:     /// @notice Signed withdraw request allowing accounts to withdraw funds from this contract.\n20:     struct WithdrawRequest {\n340:     } \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18-L20)",
            "[340](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L340-L34)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n21:     /// @notice Wrapper struct, used during signature validation, tie a signature with its signer.\n22:     struct SignatureWrapper {\n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L22)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n13: contract CoinbaseSmartWalletFactory { \n14:     /// @notice Address of the ERC-4337 implementation used as implementation for new accounts.\n15:     address public immutable implementation;\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13-L15)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n16: abstract contract ERC1271 { \n17:     /// @dev Precomputed `typeHash` used to produce EIP-712 compliant hash when applying the anti\n18:     ///      cross-account-replay layer.\n19:     ///\n20:     ///      The original hash must either be:\n21:     ///         - An EIP-191 hash: keccak256(\"\\x19Ethereum Signed Message:\\n\" || len(someMessage) || someMessage)\n22:     ///         - An EIP-712 hash: keccak256(\"\\x19\\x01\" || someDomainSeparator || hashStruct(someStruct))\n23:     bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"CoinbaseSmartWalletMessage(bytes32 hash)\");\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L16-L23)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n32: contract MultiOwnable { \n33:     /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n34:     ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n35:     ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n36:     bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n```\n",
          "loc": [
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L32-L36)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n18: library WebAuthn { \n19:     using LibString for string;\n20: \n21:     struct WebAuthnAuth {\n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L18-L21)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Typos",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit ecdsa -> sades\n15: ///* DESCRIPTION: ecdsa verification implementation \n/// @audit Github -> GitHub\n22: // Github code: https://github.com/rdubois-crypto/FreshCryptoLib/blob/d9bb3b0fc6b737af2c70dab246cabbc7d05afc3c/solidity/src/FCL_ecdsa.sol#L40 \n/// @audit precompiled -> recompiled\n28:     // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo) \n/// @audit weierstrass -> Weierstrass\n32:     //short weierstrass first coefficient \n/// @audit weierstrass -> Weierstrass\n34:     //short weierstrass second coefficient \n/// @audit precompiled -> recompiled\n106:             // Call the precompiled contract 0x05 = ModExp \n/// @audit inlined -> unlined\n165:                     // inlined EcZZ_Dbl \n/// @audit dibit -> debit\n179:                         //value of dibit \n/// @audit inlined -> unlined\n206:                         // inlined EcZZ_AddN \n/// @audit todo -> too\n214:                         //todo : construct edge vector case \n/// @audit precompiled -> recompiled\n261:                 // Call the precompiled contract 0x05 = ModExp \n/// @audit zz -> z\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z \n/// @audit precompiled -> recompiled\n386:             // Call the precompiled contract 0x05 = ModExp \n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L15)",
            "[22](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L22)",
            "[28](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L28)",
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L32)",
            "[34](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L34)",
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L106)",
            "[165](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L165)",
            "[179](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L179)",
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L206)",
            "[214](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L214)",
            "[261](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L261)",
            "[265](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L265)",
            "[386](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L386)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit Coinbase -> Coin base\n13: /// @author Coinbase (https://github.com/coinbase/magic-spend) \n/// @audit Entrypoint -> Entry point\n15: /// @notice ERC4337 Paymaster implementation compatible with Entrypoint v0.6. \n/// @audit reched -> retied\n55:     /// @notice Thrown when trying to use a withdraw request after its expiry has been reched. \n/// @audit withraw -> withdraw\n/// @audit reques -> request\n63:     /// @notice Thrown during validation in the context of ERC4337, when the withraw reques amount is insufficient \n/// @audit Entrypoint -> Entry point\n67:     /// @param maxCost   The max gas cost required by the Entrypoint. \n/// @audit  exluding -> exuding\n76:     ///         requested amount (exluding the `maxGasCost` set by the Entrypoint). \n/// @audit withdrwable -> withdrawal\n87:     /// @dev This should only really occur if for unknown reasons the transfer of the withdrwable \n/// @audit withdrawable -> withdraw able\n137:         // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`. \n/// @audit accout -> account\n154:         // Compute the total remaining funds available for the user accout. \n/// @audit consummed -> consumed\n155:         // NOTE: Take into account the user operation gas that was not consummed.\n/// @audit accout -> account\n158:         // Send the all remaining funds to the user accout. \n/// @audit Entrypoint -> Entry point\n211:     /// @param amount The amount to deposit on the the Entrypoint. \n/// @audit Entrypoint -> Entry point\n221:     /// @param amount The amount to withdraw from the Entrypoint. \n/// @audit Entrypoint -> Entry point\n230:     /// @param amount              The amount to stake in the Entrypoint. \n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L13)",
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L15)",
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L55)",
            "[63](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L63-L63)",
            "[67](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L67)",
            "[76](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L76)",
            "[87](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L87)",
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L137)",
            "[154](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L154-L155)",
            "[158](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L158)",
            "[211](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L211)",
            "[221](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L221)",
            "[230](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L230)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Coinbase -> Coin base\n13: /// @title Coinbase Smart Wallet \n/// @audit Solady -> So lady\n15: /// @notice ERC4337-compatible smart contract wallet, based on Solady ERC4337 account implementation \n/// @audit Alchemys -> Alchemy\n/// @audit Daimos -> Deimos\n16: ///         with inspiration from Alchemy's LightAccount and Daimo's DaimoAccount.\n/// @audit Coinbase -> Coin base\n18: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n/// @audit Solady -> So lady\n19: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\n/// @audit struct -> strict\n21:     /// @notice Wrapper struct, used during signature validation, tie a signature with its signer. \n/// @audit indentifying -> identifying\n23:         /// @dev The index indentifying owner (see MultiOwnable) who signed. \n/// @audit struct -> strict\n25:         /// @dev An ABI encoded ECDSA signature (r, s, v) or WebAuthnAuth struct. \n/// @audit struct -> strict\n29:     /// @notice Wrapper struct, used in `executeBatch`, describing a raw call to execute. \n/// @audit replayable -> repayable\n39:     /// @notice Reserved nonce key (upper 192 bits of `UserOperation.nonce`) for cross-chain replayable \n/// @audit replayable -> repayable\n42:     /// @dev Helps enforce sequential sequencing of replayable transactions. \n/// @audit initializable -> initialization\n103:         // Implementation should not be initializable (does not affect proxies which use their own storage). \n/// @audit implemenentation -> implementation\n122:     /// @notice Custom implemenentation of the ERC-4337 `validateUserOp` method. The EntryPoint will \n/// @audit mentionned -> mentioned\n130:     /// @dev Reverts if the signature verification fails (except for the case mentionned earlier). \n/// @audit Entrypoint -> Entry point\n134:     /// @param missingAccountFunds The missing account funds that must be deposited on the Entrypoint. \n/// @audit Entrypoint -> Entry point\n172:     /// @dev Can only be called by the Entrypoint. \n/// @audit validtion -> validation\n173:     /// @dev Reverts if the given call is not authorized to skip the chain ID validtion.\n/// @audit befor -> before\n/// @audit validatin -> validation\n174:     /// @dev `validateUserOp()` will recompute the `userOpHash` without the chain ID befor validatin\n/// @audit Entrypoint -> Entry point\n191:     /// @dev Can only be called by the Entrypoint or an owner of this account (including itself). \n/// @audit Entrypoint -> Entry point\n202:     /// @dev Can only be called by the Entrypoint or an owner of this account (including itself). \n/// @audit Impl -> Imp\n267:     /// @dev Impl taken from https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L347 \n/// @audit abi -> ab\n285:     /// @dev Reverts if the signature does not correspond to an ERC-1271 signature or to the abi \n/// @audit struct -> strict\n286:     ///      encoded version of a `WebAuthnAuth` struct.\n/// @audit abi -> ab\n/// @audit struct -> strict\n290:     /// @param signature The abi encoded `SignatureWrapper` struct. \n/// @audit incase -> encase\n304:                 // addOwnerAddress and addOwnerPublicKey, but we leave incase of future changes. \n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L15-L16)",
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L13)",
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L18-L19)",
            "[21](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L21)",
            "[23](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L23)",
            "[25](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L25)",
            "[29](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L29)",
            "[39](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L39)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L42)",
            "[103](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L103)",
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L122)",
            "[130](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L130)",
            "[134](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L134)",
            "[172](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L172-L174)",
            "[191](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L191)",
            "[202](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L202)",
            "[267](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L267)",
            "[285](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L285-L286)",
            "[290](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L290-L290)",
            "[304](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L304)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit Coinbase -> Coin base\n7: /// @title Coinbase Smart Wallet Factory \n/// @audit Soladys -> Gladys\n9: /// @notice CoinbaseSmartWallet factory, based on Solady's ERC4337Factory. \n/// @audit Coinbase -> Coin base\n11: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n/// @audit Solady -> So lady\n12: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337Factory.sol)\n/// @audit Webauthn -> Autobahn\n33:     ///      scheme used (respectively ERC-1271 or Webauthn authentication). \n```\n",
          "loc": [
            "[7](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L7)",
            "[9](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L9)",
            "[11](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L11-L12)",
            "[33](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L33)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit samer -> maser\n9: /// @dev To prevent the same signature from being validated on different accounts owned by the samer signer, \n/// @audit Coinbase -> Coin base\n14: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n/// @audit Solady -> So lady\n15: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)\n/// @audit Precomputed -> Recomputed\n17:     /// @dev Precomputed `typeHash` used to produce EIP-712 compliant hash when applying the anti \n/// @audit fron -> from\n78:     /// @notice Wrapper around `_eip712Hash()` to produce a replay-safe hash fron the given `hash`. \n/// @audit usecase -> use case\n149:     ///      of the implementation to decode `signature` depending on its usecase. \n```\n",
          "loc": [
            "[9](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L9)",
            "[14](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L14-L15)",
            "[17](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L17)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L78)",
            "[149](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L149)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit idenfitied -> identified\n10:     /// @dev Mapping of indices to raw owner bytes, used to idenfitied owners by their \n/// @audit calldata -> call data\n14:     ///      requires the caller to assert which owner signed. To economize calldata, \n/// @audit abi -> ab\n19:     ///         - An abi encoded ethereum address \n/// @audit abi -> ab\n20:     ///         - The abi encoded public key (x, y) coordinates when using passkey.\n/// @audit booleans -> boolean\n22:     /// @dev Mapping of raw bytes accounts to booleans indicating whether or not the \n/// @audit Ownable -> Own able\n27: /// @title Multi Ownable \n/// @audit Coinbase -> Coin base\n31: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n/// @audit abi -> ab\n44:     /// @param owner The raw abi encoded owner bytes. \n/// @audit intialize -> initialize\n52:     /// @notice Thrown when trying to intialize the contracts owners if a provided owner is neither \n/// @audit abi -> ab\n55:     /// @param owner The invalid raw abi encoded owner bytes. \n/// @audit intialize -> initialize\n58:     /// @notice Thrown when trying to intialize the contracts owners if a provided owner is 32 bytes \n/// @audit abi -> ab\n61:     /// @param owner The invalid raw abi encoded owner bytes. \n/// @audit abi -> ab\n67:     /// @param owner The raw abi encoded owner bytes. \n/// @audit abi -> ab\n73:     /// @param owner The raw abi encoded owner bytes. \n/// @audit intiial -> initial\n161:     /// @param owners The intiial list of owners to register. \n/// @audit fo -> few\n200:     /// @dev Revert if the sender is not an owner fo the contract itself. \n/// @audit struct -> strict\n209:     /// @notice Helper function to get a storage reference to the `MultiOwnableStorage` struct. \n/// @audit struct -> strict\n211:     /// @return $ A storage reference to the `MultiOwnableStorage` struct. \n```\n",
          "loc": [
            "[10](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L10)",
            "[14](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L14)",
            "[19](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L19-L20)",
            "[22](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L22)",
            "[27](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L27)",
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L31)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L44)",
            "[52](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L52)",
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L55)",
            "[58](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L58)",
            "[61](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L61)",
            "[67](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L67)",
            "[73](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L73)",
            "[161](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L161)",
            "[200](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L200)",
            "[209](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L209)",
            "[211](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L211)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit Daimo -> Daimler\n11: ///         of Daimo. \n/// @audit precompile -> recompile\n13: /// @dev Attempts to use the RIP-7212 precompile for signature verification. \n/// @audit precompile -> recompile\n14: ///      If precompile verification fails, it falls back to FreshCryptoLib.\n/// @audit Coinbase -> Coin base\n16: /// @author Coinbase (https://github.com/base-org/webauthn-sol) \n/// @audit Daimo -> Daimler\n17: /// @author Daimo (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)\n/// @audit authenticator -> authentication\n22:         /// @dev The WebAuthn authenticator data. \n/// @audit authenticator -> authentication\n/// @audit struct -> strict\n38:     /// @dev Bit 0 of the authenticator data struct, corresponding to the \"User Present\" bit. \n/// @audit authenticator -> authentication\n/// @audit struct -> strict\n42:     /// @dev Bit 2 of the authenticator data struct, corresponding to the \"User Verified\" bit. \n/// @audit precompiled -> recompiled\n49:     /// @dev The precompiled contract address to use for signature verification in the ‚Äúsecp256r1‚Äù elliptic curve. \n/// @audit Webauthn -> Autobahn\n58:     /// @notice Verifies a Webauthn Authentication Assertion as described \n/// @audit authenticator -> authentication\n65:     ///         - Verify that authenticatorData (which comes from the authenticator, such as iCloud Keychain) indicates \n/// @audit authenticator -> authentication\n66:     ///           a well-formed assertion with the user present bit set. If `requireUV` is set, checks that the authenticator\n/// @audit verifier -> versifier\n75:     ///      We make some assumptions about the particular use case of this verifier, so we do NOT verify the following: \n/// @audit Partys -> Party\n/// @audit tt -> rt\n76:     ///         - Does NOT verify that the origin in the `clientDataJSON` matches the Relying Party's origin: tt is considered\n/// @audit authenticators -> authentication\n77:     ///           the authenticator's responsibility to ensure that the user is interacting with the correct RP. This is\n/// @audit authenticators -> authentication\n/// @audit Keychain -> Key chain\n78:     ///           enforced by most high quality authenticators properly, particularly the iCloud Keychain and Google Password\n/// @audit behaviour -> behavior\n82:     ///           cross-origin usage of the credentials. This is the default behaviour for created credentials in common settings. \n/// @audit authenticator -> authentication\n84:     ///           Party: this means that we rely on the authenticator to properly enforce credentials to be used only by the correct RP. \n/// @audit authorised -> authorized\n86:     ///           edge cases in which a previously-linked RP ID is removed from the authorised RP IDs, we recommend that messages \n/// @audit authenticator -> authentication\n87:     ///           signed by the authenticator include some expiry mechanism.\n/// @audit struct -> strict\n99:     /// @param webAuthnAuth The `WebAuthnAuth` struct. \n/// @audit precompile -> recompile\n150:         // try the RIP-7212 precompile address \n/// @audit staticcall -> static call\n152:         // staticcall will not revert if address has no code \n/// @audit precompile -> recompile\n154:         // note that even if precompile exists, ret.length is 0 when verification returns false \n/// @audit precompile -> recompile\n155:         // so an invalid signature will be checked twice: once by the precompile and once by FCL.\n/// @audit offchain -> off chain\n156:         // Ideally this signature failure is simulated offchain and no one actually pay this gas.\n```\n",
          "loc": [
            "[11](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L11)",
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L13-L14)",
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L16-L17)",
            "[22](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L22)",
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L38-L38)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L42-L42)",
            "[49](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L49)",
            "[58](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L58)",
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L65-L66)",
            "[75](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L75-L78)",
            "[82](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L82)",
            "[84](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L84)",
            "[86](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L86-L87)",
            "[99](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L99)",
            "[150](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L150)",
            "[152](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L152)",
            "[154](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L154-L156)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Unnecessary struct attribute prefix",
      "description": "Attributes within a struct are redundantly prefixed, which is unnecessary as they are inherently associated with the struct. Consider simplifying the attribute names by removing the redundant prefix.\n\nBy removing the repetitive prefix, the code maintains its contextual clarity while becoming more concise and easy to read.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit signatureData\n22:     struct SignatureWrapper { \n23:         /// @dev The index indentifying owner (see MultiOwnable) who signed.\n24:         uint256 ownerIndex;\n25:         /// @dev An ABI encoded ECDSA signature (r, s, v) or WebAuthnAuth struct.\n26:         bytes signatureData;\n27:     }\n```\n",
          "loc": [
            "[22](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L22-L27)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Unspecific compiler version pragma",
      "description": "Some files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n24: pragma solidity >=0.8.19 <0.9.0; \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L24)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Unused `error` definition",
      "description": "The following errors are never used, consider to remove them.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n90:     error UnexpectedPostOpRevertedMode(); \n```\n",
          "loc": [
            "[90](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L90-L90)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Upgradeable contract not initialized",
      "description": "Upgradeable contracts are initialized via an initializer function rather than by a constructor. Leaving such a contract uninitialized may lead to it being taken over by a malicious user.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit __UUPS_init();\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20-L20)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use a single file for system wide constants",
      "description": "Consider grouping all the system constants under a single file. This finding shows only the first constant for each file, for brevity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n29:     address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005; \n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF; \n33:     uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC; \n35:     uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B; \n37:     uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296; \n38:     uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n40:     uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551; \n42:     uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD; \n44:     uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F; \n46:     uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \n```\n",
          "loc": [
            "[29](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L29-L29)",
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L31-L31)",
            "[33](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L33-L33)",
            "[35](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L35-L35)",
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L37-L38)",
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L40-L40)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L42-L42)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L44-L44)",
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L46-L46)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n43:     uint256 public constant REPLAYABLE_NONCE_KEY = 8453; \n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L43-L43)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n23:     bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"CoinbaseSmartWalletMessage(bytes32 hash)\"); \n```\n",
          "loc": [
            "[23](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L23-L23)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n36:     bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION = \n37:         0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n```\n",
          "loc": [
            "[36](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L36-L37)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n40:     bytes1 private constant AUTH_DATA_FLAGS_UP = 0x01; \n44:     bytes1 private constant AUTH_DATA_FLAGS_UV = 0x04; \n47:     uint256 private constant P256_N_DIV_2 = FCL.n / 2; \n51:     address private constant VERIFIER = address(0x100); \n55:     bytes32 private constant EXPECTED_TYPE_HASH = keccak256('\"type\":\"webauthn.get\"'); \n```\n",
          "loc": [
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L40-L40)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L44-L44)",
            "[47](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L47-L47)",
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L51-L51)",
            "[55](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L55-L55)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use a struct to encapsulate multiple function parameters",
      "description": "If a function has too many parameters, replacing them with a struct can improve code readability and maintainability, increase reusability, and reduce the likelihood of errors when passing the parameters.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L348)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning",
      "description": "Starting with version 0.8.4, Solidity has the `bytes.concat()` function, which allows one to concatenate a list of bytes/strings, without extra padding. Using this function rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash))); \n```\n",
          "loc": [
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L122-L122)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash)); \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L148-L148)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use EIP-5627 to describe EIP-712 domains",
      "description": "EIP-5267 is a standard which allows for the retrieval and description of EIP-712 hash domains. This enable external tools to allow users to view the fields and values that describe their domain.\n\nThis is especially useful when a project may exist on multiple chains and or in multiple contracts, and allows users/tools to verify that the signature is for the right fork, chain, version, contract, etc.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n104:                 keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"), \n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L104)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use of `override` is unnecessary",
      "description": "Starting with Solidity version [0.8.8](https://docs.soliditylang.org/en/v0.8.20/contracts.html#function-overriding), using the override keyword when the function solely overrides an interface function, and the function doesn't exist in multiple base contracts, is unnecessary.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n291:     function _validateSignature(bytes32 message, bytes calldata signature) \n292:         internal\n293:         view\n294:         virtual\n295:         override\n296:         returns (bool)\n297:     {\n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {} \n333:     function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) { \n```\n",
          "loc": [
            "[291](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L291-L297)",
            "[330](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L330-L330)",
            "[333](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L333-L333)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use UPPER_CASE for `constant`",
      "description": "Constants should be in CONSTANT_CASE as stated [Solidity style guide](https://docs.soliditylang.org/en/latest/style-guide.html#constants).",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF; \n33:     uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC; \n35:     uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B; \n37:     uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296; \n38:     uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n40:     uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551; \n42:     uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD; \n44:     uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F; \n46:     uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \n```\n",
          "loc": [
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L31-L31)",
            "[33](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L33-L33)",
            "[35](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L35-L35)",
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L37-L38)",
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L40-L40)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L42-L42)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L44-L44)",
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L46-L46)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Use UPPER_CASE for `immutable`",
      "description": "Immutables should be in uppercase as stated [Solidity style guide](https://docs.soliditylang.org/en/latest/style-guide.html#constants).",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n15:     address public immutable implementation; \n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L15-L15)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Variables should be named in mixedCase style",
      "description": "As the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html#naming-styles) suggests: arguments, local variables and mutable state variables should be named in mixedCase style.\n\nRule exceptions\n- Allow constant variable name/symbol/decimals to be lowercase (ERC20).\n- Allow `_` at the beginning of the mixedCase match for `private variables` and `unused parameters`.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Qx\n/// @audit Qy\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n/// @audit scalar_u\n61:         uint256 scalar_u = mulmod(uint256(message), sInv, n); \n/// @audit scalar_v\n62:         uint256 scalar_v = mulmod(r, sInv, n);\n/// @audit LHS\n83:             uint256 LHS = mulmod(y, y, p); // y^2 \n/// @audit RHS\n84:             uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(x, a, p), p); // x^3+ax\n/// @audit Q0\n118:         uint256 Q0, \n/// @audit Q1\n119:         uint256 Q1, //affine rep for input point Q\n/// @audit scalar_u\n120:         uint256 scalar_u,\n/// @audit scalar_v\n121:         uint256 scalar_v\n/// @audit X\n122:     ) internal view returns (uint256 X) {\n/// @audit Y\n125:         uint256 Y; \n/// @audit H0\n127:         uint256 H0; \n/// @audit H1\n128:         uint256 H1;\n/// @audit P0\n/// @audit P1\n/// @audit P2\n/// @audit P3\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3) \n/// @audit P0\n/// @audit P1\n/// @audit P2\n/// @audit P3\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3) \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[61](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L61-L62)",
            "[83](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L83-L84)",
            "[118](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L118-L122)",
            "[125](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L125-L125)",
            "[127](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L127-L128)",
            "[321](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L321-L321)",
            "[347](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L347-L347)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit _withdrawableETH\n34:     mapping(address user => uint256 amount) internal _withdrawableETH; \n/// @audit _owner\n101:     constructor(address _owner) { \n```\n",
          "loc": [
            "[34](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L34-L34)",
            "[101](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L101-L101)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit $\n241:     function implementation() public view returns (address $) { \n```\n",
          "loc": [
            "[241](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L241-L241)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit $\n212:     function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) { \n```\n",
          "loc": [
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L212-L212)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit clientDataJSON\n27:         string clientDataJSON; \n/// @audit requireUV\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n/// @audit clientDataJSONHash\n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON)); \n```\n",
          "loc": [
            "[27](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L27-L27)",
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L104)",
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L145-L145)"
          ]
        }
      ]
    },
    {
      "severity": "NonCritical",
      "title": "Zero as a function argument should have a descriptive meaning",
      "description": "Consider using descriptive constants or an enum instead of passing zero directly on function calls, as that might be error-prone, to fully describe the caller's intention.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n186:         _call(address(this), 0, data); \n```\n",
          "loc": [
            "[186](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L186-L186)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "`++i` costs less gas than `i++`/`i += 1` (same for `--i` vs `i--`/`i -+ 1`)",
      "description": "_",
      "gasSavings": 5,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "`++i`/`i++` should be `unchecked` when it is not possible for them to overflow",
      "description": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**",
      "gasSavings": 60,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "`>=`/`<=` costs less gas than `>`/`<`",
      "description": "The compiler uses opcodes `GT` and `ISZERO` for code that uses `>`, but only requires `LT` for `>=`. A similar behaviour applies for `>`, which uses opcodes `LT` and `ISZERO`, but only requires `GT` for `<=`.",
      "gasSavings": 3,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n117:         if (withdrawAmount < maxCost) { \n133:         if (address(this).balance < withdrawAmount) { \n160:         if (withdrawable > 0) { \n188:         if (block.timestamp > withdrawRequest.expiry) { \n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L117-L117)",
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L133-L133)",
            "[160](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L160-L160)",
            "[188](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L188-L188)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n206:         for (uint256 i; i < calls.length;) { \n302:             if (uint256(bytes32(ownerBytes)) > type(uint160).max) { \n```\n",
          "loc": [
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L206-L206)",
            "[302](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L302-L302)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)",
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n109:         if (webAuthnAuth.s > P256_N_DIV_2) { \n157:         bool valid = ret.length > 0; \n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L109-L109)",
            "[157](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L157-L157)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "`abi.encode()` is less efficient than `abi.encodePacked()`",
      "description": "See for more information: https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash))); \n```\n",
          "loc": [
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L122)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash)); \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L148)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if-statement`",
      "description": "\n1. `require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n2. `require(b >= a); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n3. `if (b < a) revert(...);  x = b - a` => `if (b < a) revert(...);  unchecked { x = b - a }`\n4. `if (a > b) revert(...);  x = b - a` => `if (b < a) revert(...);  unchecked { x = b - a }`",
      "gasSavings": 60,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n138:         _withdrawableETH[userOp.sender] += withdrawAmount - maxCost; \n```\n",
          "loc": [
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L138-L138)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Alternative Solady library can be used instead of OpenZeppelin to save gas",
      "description": "The following OpenZeppelin imports have a [Solady](https://github.com/Vectorized/solady) equivalent, as such they can be used to save GAS as Solady modules have been specifically designed to be as GAS efficient as possible.",
      "gasSavings": 1000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n5: import {Base64} from \"openzeppelin-contracts/contracts/utils/Base64.sol\"; \n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L5-L5)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Avoid contract existence checks by using low-level calls",
      "description": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low-level calls never check for contract existence",
      "gasSavings": 100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n223:         IEntryPoint(entryPoint()).withdrawTo(to, amount); \n233:         IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds); \n240:         IEntryPoint(entryPoint()).unlockStake(); \n249:         IEntryPoint(entryPoint()).withdrawStake(to); \n```\n",
          "loc": [
            "[223](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L223-L223)",
            "[233](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L233-L233)",
            "[240](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L240-L240)",
            "[249](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L249-L249)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Avoid unnecessary `public` variables",
      "description": "Public state variables in Solidity automatically generate getter functions, increasing contract size and potentially leading to higher deployment and interaction costs. To optimize gas usage and contract efficiency, minimize the use of public variables unless external access is necessary. Instead, use internal or private visibility combined with explicit getter functions when required. This practice not only reduces contract size but also provides better control over data access and manipulation, enhancing security and readability. Prioritize lean, efficient contracts to ensure cost-effectiveness and better performance on the blockchain.",
      "gasSavings": 22000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n15:     address public immutable implementation; \n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L15-L15)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "`bytes.concat()` can be used in place of `abi.encodePacked`",
      "description": "Given concatenation is not going to be used for hashing `bytes.concat` is the preferred method to use as its more gas efficient",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash))); \n```\n",
          "loc": [
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L122-L122)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash)); \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L148-L148)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Cache array length outside of loop",
      "description": "If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).",
      "gasSavings": 4,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n206:         for (uint256 i; i < calls.length;) { \n```\n",
          "loc": [
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L206)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider pre-calculating the address of `address(this)`",
      "description": "It can be more gas-efficient to use a hardcoded address instead of the `address(this)` expression, especially if you need to use the same address multiple times in your contract.\n\nThe reason for this, is that using `address(this)` requires an additional `EXTCODESIZE` operation to retrieve the contract‚Äôs address from its bytecode, which can increase the gas cost of your contract. By pre-calculating and using a hardcoded address, you can avoid this additional operation and reduce the overall gas cost of your contract.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n133:         if (address(this).balance < withdrawAmount) { \n134:             revert InsufficientBalance(withdrawAmount, address(this).balance);\n282:                 address(this), \n```\n",
          "loc": [
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L133-L134)",
            "[282](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L282)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n186:         _call(address(this), 0, data); \n```\n",
          "loc": [
            "[186](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L186)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this)); \n```\n",
          "loc": [
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L65)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n53:         verifyingContract = address(this); \n108:                 address(this) \n```\n",
          "loc": [
            "[53](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L53)",
            "[108](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L108)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n202:         if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) { \n```\n",
          "loc": [
            "[202](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L202)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider using OpenZeppelin's `EnumerateSet` instead of nested mappings",
      "description": "Nested mappings and multi-dimensional arrays in Solidity operate through a process of double hashing, wherein the original storage slot and the first key are concatenated and hashed, and then this hash is again concatenated with the second key and hashed. This process can be quite gas expensive due to the double-hashing operation and subsequent storage operation (sstore).\n\nOpenZeppelin's `EnumerableSet` provides a potential solution to this problem. It creates a data structure that combines the benefits of set operations with the ability to enumerate stored elements, which is not natively available in Solidity. EnumerableSet handles the element uniqueness internally and can therefore provide a more gas-efficient and collision-resistant alternative to nested mappings or multi-dimensional arrays in certain scenarios.",
      "gasSavings": 1000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n37:     mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed; \n```\n",
          "loc": [
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L37-L37)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Consider using Solady's gas optimized lib for Math",
      "description": "Utilizing gas-optimized math functions from libraries like [Solady](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol) can lead to more efficient smart contracts.\nThis is particularly beneficial in contracts where these operations are frequently used.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n128:         validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160); \n156:         uint256 withdrawable = _withdrawableETH[account] + (maxGasCost - actualGasCost); \n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L128-L128)",
            "[156](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L156-L156)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Constructors can be marked `payable`",
      "description": "Payable functions cost less gas to execute, since the compiler does not have to add extra checks to ensure that a payment wasn't provided. A constructor can safely be marked as payable, since only the deployer would be able to pass funds, and the project itself would not pass any funds.",
      "gasSavings": 21,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n101:     constructor(address _owner) { \n```\n",
          "loc": [
            "[101](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L101)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n102:     constructor() { \n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L102)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Counting down in `for` statements is more gas efficient",
      "description": "Counting down is more gas efficient than counting up because neither we are making zero variable to non-zero variable and also we will get gas refund in the last transaction when making non-zero to zero variable. [More info](https://solodit.xyz/issues/g-02-counting-down-in-for-statements-is-more-gas-efficient-code4rena-pooltogether-pooltogether-git)",
      "gasSavings": 16,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit increments @ line 209\n206:         for (uint256 i; i < calls.length;) { \n207:             _call(calls[i].target, calls[i].value, calls[i].data);\n208:             unchecked {\n209:                 ++i;\n210:             }\n211:         }\n```\n",
          "loc": [
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L206-L211)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Do not calculate constants",
      "description": "Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n47:     uint256 private constant P256_N_DIV_2 = FCL.n / 2; \n```\n",
          "loc": [
            "[47](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L47-L47)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "`do`-`while` is cheaper than `for`-loops when the initial check can be skipped",
      "description": "Using `do-while` loops instead of `for` loops can be more gas-efficient.\nEven if you add an `if` condition to account for the case where the loop doesn't execute at all, a `do-while` loop can still be cheaper in terms of gas.",
      "gasSavings": 255,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n206:         for (uint256 i; i < calls.length;) { \n```\n",
          "loc": [
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L206-L206)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Don't transfer with zero amount to save gas",
      "description": "In Solidity, unnecessary operations can waste gas. For example, a transfer function without a zero amount check uses gas even if called with a zero amount, since the contract state remains unchanged. Implementing a zero amount check avoids these unnecessary function calls, saving gas and improving efficiency.",
      "gasSavings": 20,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit check for zero amount on the 'amount' variable\n338:             SafeTransferLib.safeTransfer(asset, to, amount); \n```\n",
          "loc": [
            "[338](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L338-L338)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Empty blocks should be removed or emit something",
      "description": "Some functions don't have a body: consider commenting why, or add some logic. Otherwise, refactor the code and remove these functions.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n106:     receive() external payable {} \n```\n",
          "loc": [
            "[106](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L106-L106)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {} \n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L330-L330)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Function names can be optimized",
      "description": "Function that are `public`/`external` and `public` state variable names can be optimized to save gas.\n\nMethod IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, per sorted position shifted. [Reference](https://blog.emn178.cc/en/post/solidity-gas-optimization-function-name/)",
      "gasSavings": 128,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit optimized order: validatePaymasterUserOp(), entryPointWithdrawStake(), withdraw(), entryPointUnlockStake(), entryPoint(), postOp(), entryPointWithdraw(), entryPointDeposit(), entryPointAddStake(), getHash(), ownerWithdraw(), nonceUsed(), withdrawGasExcess(), isValidWithdrawSignature(), _validateRequest(), _withdraw()\n18: contract MagicSpend is Ownable, IPaymaster { \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L18)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit optimized order: executeWithoutChainIdValidation(), execute(), entryPoint(), canSkipChainIdValidation(), initialize(), implementation(), getUserOpHashWithoutChainId(), validateUserOp(), executeBatch(), _call(), _validateSignature(), _authorizeUpgrade(), _domainNameAndVersion()\n20: contract CoinbaseSmartWallet is MultiOwnable, UUPSUpgradeable, Receiver, ERC1271 { \n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L20)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit optimized order: initCodeHash(), createAccount(), getAddress(), _getSalt()\n13: contract CoinbaseSmartWalletFactory { \n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit optimized order: domainSeparator(), replaySafeHash(), eip712Domain(), isValidSignature(), _eip712Hash(), _hashStruct(), _domainNameAndVersion(), _validateSignature()\n16: abstract contract ERC1271 { \n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L16)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit optimized order: nextOwnerIndex(), isOwnerAddress(), ownerAtIndex(), removeOwnerAtIndex(), addOwnerPublicKey(), isOwnerBytes(), addOwnerAddress(), isOwnerPublicKey(), _initializeOwners(), _addOwner(), _addOwnerAtIndex(), _checkOwner(), _getMultiOwnableStorage()\n32: contract MultiOwnable { \n```\n",
          "loc": [
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L32)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Functions guaranteed to revert when called by normal users can be marked `payable`",
      "description": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.",
      "gasSavings": 21,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost) \n144:         external\n145:         onlyEntryPoint\n146:     {\n203:     function ownerWithdraw(address asset, address to, uint256 amount) external onlyOwner { \n222:     function entryPointWithdraw(address payable to, uint256 amount) external onlyOwner { \n239:     function entryPointUnlockStake() external onlyOwner { \n248:     function entryPointWithdrawStake(address payable to) external onlyOwner { \n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L113)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L143-L146)",
            "[203](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L203-L203)",
            "[222](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L222-L222)",
            "[239](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L239-L239)",
            "[248](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L248-L248)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {} \n```\n",
          "loc": [
            "[330](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L330-L330)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n85:     function addOwnerAddress(address owner) public virtual onlyOwner { \n93:     function addOwnerPublicKey(bytes32 x, bytes32 y) public virtual onlyOwner { \n102:     function removeOwnerAtIndex(uint256 index) public virtual onlyOwner { \n```\n",
          "loc": [
            "[85](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L85-L85)",
            "[93](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L93-L93)",
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L102-L102)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Integer increments by one can be unchecked",
      "description": "Using unchecked increments in Solidity can save on gas fees by bypassing built-in overflow checks, thus optimizing gas usage, but requires careful assessment of potential risks and edge cases to avoid unintended consequences.",
      "gasSavings": 60,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n172:             _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++); \n180:         _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++); \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)",
            "[172](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L172-L172)",
            "[180](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L180-L180)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Low-level `call` can be optimized with assembly",
      "description": "`returnData` is copied to memory even if the variable is not utilized: the proper way to handle this is through a low level assembly call and save **159** [gas](https://gist.github.com/IllIllI000/0e18a40f3afb0b83f9a347b10ee89ad2).\n\n```solidity\n // before (bool success,) = payable(receiver).call{gas: gas, value: value}(\"\");\n//after bool success; assembly { success := call(gas, receiver, value, 0, 0, 0, 0) }\n```\n",
      "gasSavings": 159,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n273:         (bool success, bytes memory result) = target.call{value: value}(data); \n```\n",
          "loc": [
            "[273](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L273)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n151:         (bool success, bytes memory ret) = VERIFIER.staticcall(args); \n```\n",
          "loc": [
            "[151](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L151)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Multiple accesses of the same mapping/array key/index should be cached",
      "description": "The instances below point to the second+ access of a value inside a mapping/array key/index, within a function. Caching a mapping's value in a local storage or calldata variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata",
      "gasSavings": 42,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit _nonceUsed[withdrawRequest.nonce][account] is also accessed on line 316\n320:         _nonceUsed[withdrawRequest.nonce][account] = true; \n```\n",
          "loc": [
            "[320](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L320-L320)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit webAuthnAuth.authenticatorData[32] is also accessed on line 133\n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) { \n```\n",
          "loc": [
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L138-L138)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Nesting `if`-statements is cheaper than using `&&`",
      "description": "Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.",
      "gasSavings": 30,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n131:             if (scalar_u == 0 && scalar_v == 0) return 0; \n134:             if ( \n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n280:         if ((x0 == x1) && (y0 == y1)) { \n```\n",
          "loc": [
            "[131](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L131-L131)",
            "[134](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L134-L135)",
            "[280](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L280-L280)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) { \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L148-L148)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n164:             if (owners[i].length != 32 && owners[i].length != 64) { \n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n```\n",
          "loc": [
            "[164](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L164-L164)",
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) { \n158:         if (success && valid) return abi.decode(ret, (uint256)) == 1; \n```\n",
          "loc": [
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L138-L138)",
            "[158](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L158-L158)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Newer versions of solidity are more gas efficient",
      "description": "The solidity language continues to pursue more efficient gas optimization schemes. Adopting a [newer version of solidity](https://github.com/ethereum/solc-js/tags) can be more gas efficient.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n24: pragma solidity >=0.8.19 <0.9.0; \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L24)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n2: pragma solidity 0.8.23; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n2: pragma solidity 0.8.23; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n2: pragma solidity ^0.8.0; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L2)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Not using the named return variables when a function returns, wastes deployment gas",
      "description": "The solidity compiler outputs more efficient code when the variable is declared in the return statement. There seem to be very few exceptions to this in practice, so if you see an anonymous return, you should test it with a named return instead to determine which case is most efficient.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Parameter of type 'bool' at index '0'\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n/// @audit Parameter of type 'bool' at index '0'\n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n95:         assembly {\n96:             let pointer := mload(0x40)\n97:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n98:             mstore(pointer, 0x20)\n99:             mstore(add(pointer, 0x20), 0x20)\n100:             mstore(add(pointer, 0x40), 0x20)\n101:             // Define variables base, exponent and modulus\n102:             mstore(add(pointer, 0x60), u)\n103:             mstore(add(pointer, 0x80), minus_2modn)\n104:             mstore(add(pointer, 0xa0), n)\n105: \n106:             // Call the precompiled contract 0x05 = ModExp\n107:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n108:             result := mload(pointer)\n109:         }\n110:     }\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n123:         uint256 zz;\n124:         uint256 zzz;\n125:         uint256 Y;\n126:         uint256 index = 255;\n127:         uint256 H0;\n128:         uint256 H1;\n129: \n130:         unchecked {\n131:             if (scalar_u == 0 && scalar_v == 0) return 0;\n132: \n133:             (H0, H1) = ecAff_add(gx, gy, Q0, Q1);\n134:             if (\n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n136:             ) {\n137:                 scalar_u = addmod(scalar_u, n - scalar_v, n);\n138:                 scalar_v = 0;\n139:             }\n140:             assembly {\n141:                 for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n142:                     index := sub(index, 1)\n143:                     T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n144:                 } {}\n145:                 zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n146: \n147:                 if eq(zz, 1) {\n148:                     X := gx\n149:                     Y := gy\n150:                 }\n151:                 if eq(zz, 2) {\n152:                     X := Q0\n153:                     Y := Q1\n154:                 }\n155:                 if eq(zz, 3) {\n156:                     X := H0\n157:                     Y := H1\n158:                 }\n159: \n160:                 index := sub(index, 1)\n161:                 zz := 1\n162:                 zzz := 1\n163: \n164:                 for {} gt(minus_1, index) { index := sub(index, 1) } {\n165:                     // inlined EcZZ_Dbl\n166:                     let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n167:                     let T2 := mulmod(T1, T1, p) // V=U^2\n168:                     let T3 := mulmod(X, T2, p) // S = X1*V\n169:                     T1 := mulmod(T1, T2, p) // W=UV\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n173: \n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n177: \n178:                     {\n179:                         //value of dibit\n180:                         T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n181: \n182:                         if iszero(T4) {\n183:                             Y := sub(p, Y) //restore the -Y inversion\n184:                             continue\n185:                         } // if T4!=0\n186: \n187:                         if eq(T4, 1) {\n188:                             T1 := gx\n189:                             T2 := gy\n190:                         }\n191:                         if eq(T4, 2) {\n192:                             T1 := Q0\n193:                             T2 := Q1\n194:                         }\n195:                         if eq(T4, 3) {\n196:                             T1 := H0\n197:                             T2 := H1\n198:                         }\n199:                         if iszero(zz) {\n200:                             X := T1\n201:                             Y := T2\n202:                             zz := 1\n203:                             zzz := 1\n204:                             continue\n205:                         }\n206:                         // inlined EcZZ_AddN\n207: \n208:                         //T3:=sub(p, Y)\n209:                         //T3:=Y\n210:                         let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n212: \n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n214:                         //todo : construct edge vector case\n215:                         if iszero(y2) {\n216:                             if iszero(T2) {\n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n220: \n221:                                 T1 := mulmod(T1, T2, p) // W=UV\n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n224: \n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n227: \n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n230: \n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n232: \n233:                                 continue\n234:                             }\n235:                         }\n236: \n237:                         T4 := mulmod(T2, T2, p) //PP\n238:                         let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n239:                         zz := mulmod(zz, T4, p)\n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n241:                         let TT2 := mulmod(X, T4, p)\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n244: \n245:                         X := T4\n246:                     }\n247:                 } //end loop\n248:                 let T := mload(0x40)\n249:                 mstore(add(T, 0x60), zz)\n250:                 //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n251:                 //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n252:                 // Define length of base, exponent and modulus. 0x20 == 32 bytes\n253:                 mstore(T, 0x20)\n254:                 mstore(add(T, 0x20), 0x20)\n255:                 mstore(add(T, 0x40), 0x20)\n256:                 // Define variables base, exponent and modulus\n257:                 //mstore(add(pointer, 0x60), u)\n258:                 mstore(add(T, 0x80), minus_2)\n259:                 mstore(add(T, 0xa0), p)\n260: \n261:                 // Call the precompiled contract 0x05 = ModExp\n262:                 if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n263: \n264:                 //Y:=mulmod(Y,zzz,p)//Y/zzz\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z\n266:                 //zz:= mulmod(zz,zz,p) //1/zz\n267:                 X := mulmod(X, mload(T), p) //X/zz\n268:             } //end assembly\n269:         } //end unchecked\n270: \n271:         return X;\n272:     }\n/// @audit Parameter of type 'uint256' at index '0'\n/// @audit Parameter of type 'uint256' at index '1'\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n294:         return (y == 0);\n295:     }\n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n302:         internal\n303:         view\n304:         returns (uint256 x1, uint256 y1)\n305:     {\n306:         uint256 zzzInv = FCL_pModInv(zzz); //1/zzz\n307:         y1 = mulmod(y, zzzInv, p); //Y/zzz\n308:         uint256 _b = mulmod(zz, zzzInv, p); //1/z\n309:         zzzInv = mulmod(_b, _b, p); //1/zz\n310:         x1 = mulmod(x, zzzInv, p); //X/zz\n311:     }\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n323:         unchecked {\n324:             assembly {\n325:                 P0 := mulmod(2, y, p) //U = 2*Y1\n326:                 P2 := mulmod(P0, P0, p) // V=U^2\n327:                 P3 := mulmod(x, P2, p) // S = X1*V\n328:                 P1 := mulmod(P0, P2, p) // W=UV\n329:                 P2 := mulmod(P2, zz, p) //zz3=V*ZZ1\n330:                 zz := mulmod(3, mulmod(addmod(x, sub(p, zz), p), addmod(x, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n331:                 P0 := addmod(mulmod(zz, zz, p), mulmod(minus_2, P3, p), p) //X3=M^2-2S\n332:                 x := mulmod(zz, addmod(P3, sub(p, P0), p), p) //M(S-X3)\n333:                 P3 := mulmod(P1, zzz, p) //zzz3=W*zzz1\n334:                 P1 := addmod(x, sub(p, mulmod(P1, y, p)), p) //Y3= M(S-X3)-W*Y1\n335:             }\n336:         }\n337:         return (P0, P1, P2, P3);\n338:     }\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n349:         unchecked {\n350:             if (y1 == 0) {\n351:                 return (x2, y2, 1, 1);\n352:             }\n353: \n354:             assembly {\n355:                 y1 := sub(p, y1)\n356:                 y2 := addmod(mulmod(y2, zzz1, p), y1, p)\n357:                 x2 := addmod(mulmod(x2, zz1, p), sub(p, x1), p)\n358:                 P0 := mulmod(x2, x2, p) //PP = P^2\n359:                 P1 := mulmod(P0, x2, p) //PPP = P*PP\n360:                 P2 := mulmod(zz1, P0, p) ////ZZ3 = ZZ1*PP\n361:                 P3 := mulmod(zzz1, P1, p) ////ZZZ3 = ZZZ1*PPP\n362:                 zz1 := mulmod(x1, P0, p) //Q = X1*PP\n363:                 P0 := addmod(addmod(mulmod(y2, y2, p), sub(p, P1), p), mulmod(minus_2, zz1, p), p) //R^2-PPP-2*Q\n364:                 P1 := addmod(mulmod(addmod(zz1, sub(p, P0), p), y2, p), mulmod(y1, P1, p), p) //R*(Q-X3)\n365:             }\n366:             //end assembly\n367:         } //end unchecked\n368:         return (P0, P1, P2, P3);\n369:     }\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n375:         assembly {\n376:             let pointer := mload(0x40)\n377:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n378:             mstore(pointer, 0x20)\n379:             mstore(add(pointer, 0x20), 0x20)\n380:             mstore(add(pointer, 0x40), 0x20)\n381:             // Define variables base, exponent and modulus\n382:             mstore(add(pointer, 0x60), u)\n383:             mstore(add(pointer, 0x80), minus_2)\n384:             mstore(add(pointer, 0xa0), p)\n385: \n386:             // Call the precompiled contract 0x05 = ModExp\n387:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n388:             result := mload(pointer)\n389:         }\n390:     }\n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L78)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L110)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L272)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L295)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L311)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L338)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L369)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L390)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost) \n110:         external\n111:         onlyEntryPoint\n112:         returns (bytes memory context, uint256 validationData)\n113:     {\n114:         WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest));\n115:         uint256 withdrawAmount = withdrawRequest.amount;\n116: \n117:         if (withdrawAmount < maxCost) {\n118:             revert RequestLessThanGasMaxCost(withdrawAmount, maxCost);\n119:         }\n120: \n121:         if (withdrawRequest.asset != address(0)) {\n122:             revert UnsupportedPaymasterAsset(withdrawRequest.asset);\n123:         }\n124: \n125:         _validateRequest(userOp.sender, withdrawRequest);\n126: \n127:         bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest);\n128:         validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160);\n129: \n130:         // Ensure at validation that the contract has enough balance to cover the requested funds.\n131:         // NOTE: This check is necessary to enforce that the contract will be able to transfer the remaining funds\n132:         //       when `postOp()` is called back after the `UserOperation` has been executed.\n133:         if (address(this).balance < withdrawAmount) {\n134:             revert InsufficientBalance(withdrawAmount, address(this).balance);\n135:         }\n136: \n137:         // NOTE: Do not include the gas part in withdrawable funds as it will be handled in `postOp()`.\n138:         _withdrawableETH[userOp.sender] += withdrawAmount - maxCost;\n139:         context = abi.encode(maxCost, userOp.sender);\n140:     }\n260:     function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest) \n/// @audit Parameter of type 'bytes32' at index '0'\n279:     function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) { \n/// @audit Parameter of type 'bool' at index '0'\n299:     function nonceUsed(address account, uint256 nonce) external view returns (bool) { \n/// @audit Parameter of type 'address' at index '0'\n304:     function entryPoint() public pure returns (address) { \n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L109-L140)",
            "[260](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L260-L260)",
            "[279](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L279-L279)",
            "[299](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L299-L299)",
            "[304](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L304-L304)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n145:         uint256 key = userOp.nonce >> 64;\n146: \n147:         // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n149:             userOpHash = getUserOpHashWithoutChainId(userOp);\n150:             if (key != REPLAYABLE_NONCE_KEY) {\n151:                 revert InvalidNonceKey(key);\n152:             }\n153:         } else {\n154:             if (key == REPLAYABLE_NONCE_KEY) {\n155:                 revert InvalidNonceKey(key);\n156:             }\n157:         }\n158: \n159:         // Return 0 if the recovered address matches the owner.\n160:         if (_validateSignature(userOpHash, userOp.signature)) {\n161:             return 0;\n162:         }\n163: \n164:         // Else return 1, which is equivalent to:\n165:         // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n166:         // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n167:         return 1;\n168:     }\n/// @audit Parameter of type 'address' at index '0'\n217:     function entryPoint() public view virtual returns (address) { \n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n235:         return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint()));\n236:     }\n241:     function implementation() public view returns (address $) { \n242:         assembly {\n243:             $ := sload(_ERC1967_IMPLEMENTATION_SLOT)\n244:         }\n245:     }\n/// @audit Parameter of type 'bool' at index '0'\n252:     function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) { \n291:     function _validateSignature(bytes32 message, bytes calldata signature) \n/// @audit Parameter of type 'string' at index '0'\n/// @audit Parameter of type 'string' at index '1'\n333:     function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) { \n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L168)",
            "[217](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L217-L217)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L236)",
            "[241](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L241-L245)",
            "[252](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L252-L252)",
            "[291](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L291-L291)",
            "[333](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L333-L333)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n38:     function createAccount(bytes[] calldata owners, uint256 nonce) \n39:         public\n40:         payable\n41:         virtual\n42:         returns (CoinbaseSmartWallet account)\n43:     {\n44:         if (owners.length == 0) {\n45:             revert OwnerRequired();\n46:         }\n47: \n48:         (bool alreadyDeployed, address accountAddress) =\n49:             LibClone.createDeterministicERC1967(msg.value, implementation, _getSalt(owners, nonce));\n50: \n51:         account = CoinbaseSmartWallet(payable(accountAddress));\n52: \n53:         if (alreadyDeployed == false) {\n54:             account.initialize(owners);\n55:         }\n56:     }\n64:     function getAddress(bytes[] calldata owners, uint256 nonce) external view returns (address predicted) { \n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this));\n66:     }\n71:     function initCodeHash() public view virtual returns (bytes32 result) { \n72:         result = LibClone.initCodeHashERC1967(implementation);\n73:     }\n81:     function _getSalt(bytes[] calldata owners, uint256 nonce) internal pure returns (bytes32 salt) { \n82:         salt = keccak256(abi.encode(owners, nonce));\n83:     }\n```\n",
          "loc": [
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L38-L56)",
            "[64](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L64-L66)",
            "[71](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L71-L73)",
            "[81](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L81-L83)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n36:     function eip712Domain() \n37:         external\n38:         view\n39:         virtual\n40:         returns (\n41:             bytes1 fields,\n42:             string memory name,\n43:             string memory version,\n44:             uint256 chainId,\n45:             address verifyingContract,\n46:             bytes32 salt,\n47:             uint256[] memory extensions\n48:         )\n49:     {\n50:         fields = hex\"0f\"; // `0b1111`.\n51:         (name, version) = _domainNameAndVersion();\n52:         chainId = block.chainid;\n53:         verifyingContract = address(this);\n54:         salt = salt; // `bytes32(0)`.\n55:         extensions = extensions; // `new uint256[](0)`.\n56:     }\n69:     function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4 result) { \n70:         if (_validateSignature({message: replaySafeHash(hash), signature: signature})) {\n71:             // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n72:             return 0x1626ba7e;\n73:         }\n74: \n75:         return 0xffffffff;\n76:     }\n/// @audit Parameter of type 'bytes32' at index '0'\n90:     function replaySafeHash(bytes32 hash) public view virtual returns (bytes32) { \n/// @audit Parameter of type 'bytes32' at index '0'\n100:     function domainSeparator() public view returns (bytes32) { \n/// @audit Parameter of type 'bytes32' at index '0'\n121:     function _eip712Hash(bytes32 hash) internal view virtual returns (bytes32) { \n/// @audit Parameter of type 'bytes32' at index '0'\n133:     function _hashStruct(bytes32 hash) internal view virtual returns (bytes32) { \n143:     function _domainNameAndVersion() internal view virtual returns (string memory name, string memory version); \n/// @audit Parameter of type 'bool' at index '0'\n155:     function _validateSignature(bytes32 message, bytes calldata signature) internal view virtual returns (bool); \n```\n",
          "loc": [
            "[36](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L36-L56)",
            "[69](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L69-L76)",
            "[90](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L90-L90)",
            "[100](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L100-L100)",
            "[121](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L121-L121)",
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L133-L133)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L143-L143)",
            "[155](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L155-L155)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit Parameter of type 'bool' at index '0'\n117:     function isOwnerAddress(address account) public view virtual returns (bool) { \n/// @audit Parameter of type 'bool' at index '0'\n127:     function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) { \n/// @audit Parameter of type 'bool' at index '0'\n136:     function isOwnerBytes(bytes memory account) public view virtual returns (bool) { \n/// @audit Parameter of type 'bytes' at index '0'\n145:     function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) { \n/// @audit Parameter of type 'uint256' at index '0'\n152:     function nextOwnerIndex() public view virtual returns (uint256) { \n212:     function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) { \n213:         assembly (\"memory-safe\") {\n214:             $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n215:         }\n216:     }\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L117-L117)",
            "[127](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L127-L127)",
            "[136](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L136-L136)",
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L145-L145)",
            "[152](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L152-L152)",
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L212-L216)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L104)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Optimize Deployment Size by Fine-tuning IPFS Hash",
      "description": "The Solidity compiler appends 53 bytes of metadata to the smart contract code, incurring an extra cost of 10,600 gas. This additional expense arises from 200 gas per bytecode, plus calldata cost, which amounts to 16 gas for non-zero bytes and 4 gas for zero bytes. This results in a maximum of 848 extra gas in calldata cost.\n\nReducing this cost is crucial for the following reasons:\n\nThe metadata's 53-byte addition leads to a deployment cost increase of 10,600 gas.\nIt can also result in an additional calldata cost of up to 848 gas.\nWays to Minimize Gas Consumption:\n\nEmploy the `--no-cbor-metadata` compiler option to exclude metadata. Be cautious as this might impact contract verification.\nSearch for code comments that yield an IPFS hash with more zeros, thereby reducing calldata costs.",
      "gasSavings": 10600,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: //curve order (number of points) \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L1-L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L1-L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L1-L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L1-L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L1-L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L1-L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit Consider optimizing the IPFS hash during deployment.\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L1-L1)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Simple checks for zero can be done using assembly to save gas",
      "description": "_",
      "gasSavings": 6,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n51:         if (r == 0 || r >= n || s == 0 || s >= n) { \n79:         if (((0 == x) && (0 == y)) || x == p || y == p) { \n131:             if (scalar_u == 0 && scalar_v == 0) return 0; \n134:             if ( \n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n350:             if (y1 == 0) { \n```\n",
          "loc": [
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L51-L51)",
            "[79](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L79-L79)",
            "[131](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L131-L131)",
            "[134](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L134-L135)",
            "[350](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L350-L350)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n121:         if (withdrawRequest.asset != address(0)) { \n172:         if (amount == 0) revert NoExcess(); \n335:         if (asset == address(0)) { \n```\n",
          "loc": [
            "[121](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L121-L121)",
            "[172](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L172-L172)",
            "[335](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L335-L335)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n115:         if (nextOwnerIndex() != 0) { \n```\n",
          "loc": [
            "[115](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L115-L115)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n44:         if (owners.length == 0) { \n```\n",
          "loc": [
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L44-L44)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n104:         if (owner.length == 0) revert NoOwnerAtIndex(index); \n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L104-L104)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Sort Solidity operations using short-circuit mode",
      "description": "In Solidity, boolean expressions utilize short-circuiting. For || (logical OR) operations, the second expression is evaluated only if the first one is false. Similarly, for && (logical AND) operations, the second expression is evaluated only if the first one is true. This optimization saves gas by avoiding unnecessary evaluations. For instance, in require(msg.sender == owner || msg.sender == manager), if msg.sender == owner evaluates to true, msg.sender == manager isn't checked. It's recommended to place the less expensive expression first to optimize gas usage.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit Lines: 51 \n/// @audit Lines: 51 \n/// @audit Lines: 51 \n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n51:         if (r == 0 || r >= n || s == 0 || s >= n) {\n52:             return false;\n53:         }\n54: \n55:         if (!ecAff_isOnCurve(Qx, Qy)) {\n56:             return false;\n57:         }\n58: \n59:         uint256 sInv = FCL_nModInv(s);\n60: \n61:         uint256 scalar_u = mulmod(uint256(message), sInv, n);\n62:         uint256 scalar_v = mulmod(r, sInv, n);\n63:         uint256 x1;\n64: \n65:         x1 = ecZZ_mulmuladd_S_asm(Qx, Qy, scalar_u, scalar_v);\n66: \n67:         x1 = addmod(x1, n - r, n);\n68: \n69:         return x1 == 0;\n70:     }\n/// @audit Lines: 79 \n/// @audit Lines: 79 \n/// @audit Lines: 79 \n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n79:         if (((0 == x) && (0 == y)) || x == p || y == p) {\n80:             return false;\n81:         }\n82:         unchecked {\n83:             uint256 LHS = mulmod(y, y, p); // y^2\n84:             uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(x, a, p), p); // x^3+ax\n85:             RHS = addmod(RHS, b, p); // x^3 + a*x + b\n86: \n87:             return LHS == RHS;\n88:         }\n89:     }\n/// @audit Lines: 131 \n/// @audit Lines: 134 to 135\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n123:         uint256 zz;\n124:         uint256 zzz;\n125:         uint256 Y;\n126:         uint256 index = 255;\n127:         uint256 H0;\n128:         uint256 H1;\n129: \n130:         unchecked {\n131:             if (scalar_u == 0 && scalar_v == 0) return 0;\n132: \n133:             (H0, H1) = ecAff_add(gx, gy, Q0, Q1);\n134:             if (\n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n136:             ) {\n137:                 scalar_u = addmod(scalar_u, n - scalar_v, n);\n138:                 scalar_v = 0;\n139:             }\n140:             assembly {\n141:                 for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n142:                     index := sub(index, 1)\n143:                     T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n144:                 } {}\n145:                 zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n146: \n147:                 if eq(zz, 1) {\n148:                     X := gx\n149:                     Y := gy\n150:                 }\n151:                 if eq(zz, 2) {\n152:                     X := Q0\n153:                     Y := Q1\n154:                 }\n155:                 if eq(zz, 3) {\n156:                     X := H0\n157:                     Y := H1\n158:                 }\n159: \n160:                 index := sub(index, 1)\n161:                 zz := 1\n162:                 zzz := 1\n163: \n164:                 for {} gt(minus_1, index) { index := sub(index, 1) } {\n165:                     // inlined EcZZ_Dbl\n166:                     let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n167:                     let T2 := mulmod(T1, T1, p) // V=U^2\n168:                     let T3 := mulmod(X, T2, p) // S = X1*V\n169:                     T1 := mulmod(T1, T2, p) // W=UV\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n173: \n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n177: \n178:                     {\n179:                         //value of dibit\n180:                         T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n181: \n182:                         if iszero(T4) {\n183:                             Y := sub(p, Y) //restore the -Y inversion\n184:                             continue\n185:                         } // if T4!=0\n186: \n187:                         if eq(T4, 1) {\n188:                             T1 := gx\n189:                             T2 := gy\n190:                         }\n191:                         if eq(T4, 2) {\n192:                             T1 := Q0\n193:                             T2 := Q1\n194:                         }\n195:                         if eq(T4, 3) {\n196:                             T1 := H0\n197:                             T2 := H1\n198:                         }\n199:                         if iszero(zz) {\n200:                             X := T1\n201:                             Y := T2\n202:                             zz := 1\n203:                             zzz := 1\n204:                             continue\n205:                         }\n206:                         // inlined EcZZ_AddN\n207: \n208:                         //T3:=sub(p, Y)\n209:                         //T3:=Y\n210:                         let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n212: \n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n214:                         //todo : construct edge vector case\n215:                         if iszero(y2) {\n216:                             if iszero(T2) {\n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n220: \n221:                                 T1 := mulmod(T1, T2, p) // W=UV\n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n224: \n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n227: \n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n230: \n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n232: \n233:                                 continue\n234:                             }\n235:                         }\n236: \n237:                         T4 := mulmod(T2, T2, p) //PP\n238:                         let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n239:                         zz := mulmod(zz, T4, p)\n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n241:                         let TT2 := mulmod(X, T4, p)\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n244: \n245:                         X := T4\n246:                     }\n247:                 } //end loop\n248:                 let T := mload(0x40)\n249:                 mstore(add(T, 0x60), zz)\n250:                 //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n251:                 //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n252:                 // Define length of base, exponent and modulus. 0x20 == 32 bytes\n253:                 mstore(T, 0x20)\n254:                 mstore(add(T, 0x20), 0x20)\n255:                 mstore(add(T, 0x40), 0x20)\n256:                 // Define variables base, exponent and modulus\n257:                 //mstore(add(pointer, 0x60), u)\n258:                 mstore(add(T, 0x80), minus_2)\n259:                 mstore(add(T, 0xa0), p)\n260: \n261:                 // Call the precompiled contract 0x05 = ModExp\n262:                 if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n263: \n264:                 //Y:=mulmod(Y,zzz,p)//Y/zzz\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z\n266:                 //zz:= mulmod(zz,zz,p) //1/zz\n267:                 X := mulmod(X, mload(T), p) //X/zz\n268:             } //end assembly\n269:         } //end unchecked\n270: \n271:         return X;\n272:     }\n/// @audit Lines: 280 to 281\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n275:         uint256 zz0;\n276:         uint256 zzz0;\n277: \n278:         if (ecAff_IsZero(x0, y0)) return (x1, y1);\n279:         if (ecAff_IsZero(x1, y1)) return (x0, y0);\n280:         if ((x0 == x1) && (y0 == y1)) {\n281:             (x0, y0, zz0, zzz0) = ecZZ_Dbl(x0, y0, 1, 1);\n282:         } else {\n283:             (x0, y0, zz0, zzz0) = ecZZ_AddN(x0, y0, 1, 1, x1, y1);\n284:         }\n285: \n286:         return ecZZ_SetAff(x0, y0, zz0, zzz0);\n287:     }\n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L70)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L89)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L272)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L287)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit Lines: 148 to 154\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n145:         uint256 key = userOp.nonce >> 64;\n146: \n147:         // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n149:             userOpHash = getUserOpHashWithoutChainId(userOp);\n150:             if (key != REPLAYABLE_NONCE_KEY) {\n151:                 revert InvalidNonceKey(key);\n152:             }\n153:         } else {\n154:             if (key == REPLAYABLE_NONCE_KEY) {\n155:                 revert InvalidNonceKey(key);\n156:             }\n157:         }\n158: \n159:         // Return 0 if the recovered address matches the owner.\n160:         if (_validateSignature(userOpHash, userOp.signature)) {\n161:             return 0;\n162:         }\n163: \n164:         // Else return 1, which is equivalent to:\n165:         // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n166:         // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n167:         return 1;\n168:     }\n/// @audit Lines: 253 to 259\n/// @audit Lines: 253 to 259\n/// @audit Lines: 253 to 259\n252:     function canSkipChainIdValidation(bytes4 functionSelector) public pure returns (bool) { \n253:         if (\n254:             functionSelector == MultiOwnable.addOwnerPublicKey.selector\n255:                 || functionSelector == MultiOwnable.addOwnerAddress.selector\n256:                 || functionSelector == MultiOwnable.removeOwnerAtIndex.selector\n257:                 || functionSelector == UUPSUpgradeable.upgradeToAndCall.selector\n258:         ) {\n259:             return true;\n260:         }\n261:         return false;\n262:     }\n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L168)",
            "[252](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L252-L262)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit Lines: 164 to 168\n/// @audit Lines: 168 to 172\n162:     function _initializeOwners(bytes[] memory owners) internal virtual { \n163:         for (uint256 i; i < owners.length; i++) {\n164:             if (owners[i].length != 32 && owners[i].length != 64) {\n165:                 revert InvalidOwnerBytesLength(owners[i]);\n166:             }\n167: \n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) {\n169:                 revert InvalidEthereumAddressOwner(owners[i]);\n170:             }\n171: \n172:             _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++);\n173:         }\n174:     }\n/// @audit Lines: 202 to 204\n201:     function _checkOwner() internal view virtual { \n202:         if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) {\n203:             return;\n204:         }\n205: \n206:         revert Unauthorized();\n207:     }\n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L162-L174)",
            "[201](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L201-L207)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit Lines: 138 to 141\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n105:         internal\n106:         view\n107:         returns (bool)\n108:     {\n109:         if (webAuthnAuth.s > P256_N_DIV_2) {\n110:             // guard against signature malleability\n111:             return false;\n112:         }\n113: \n114:         // 11. Verify that the value of C.type is the string webauthn.get.\n115:         // bytes(\"type\":\"webauthn.get\").length = 21\n116:         string memory _type = webAuthnAuth.clientDataJSON.slice(webAuthnAuth.typeIndex, webAuthnAuth.typeIndex + 21);\n117:         if (keccak256(bytes(_type)) != EXPECTED_TYPE_HASH) {\n118:             return false;\n119:         }\n120: \n121:         // 12. Verify that the value of C.challenge equals the base64url encoding of options.challenge.\n122:         bytes memory expectedChallenge = bytes(string.concat('\"challenge\":\"', Base64.encodeURL(challenge), '\"'));\n123:         string memory actualChallenge = webAuthnAuth.clientDataJSON.slice(\n124:             webAuthnAuth.challengeIndex, webAuthnAuth.challengeIndex + expectedChallenge.length\n125:         );\n126:         if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) {\n127:             return false;\n128:         }\n129: \n130:         // Skip 13., 14., 15.\n131: \n132:         // 16. Verify that the UP bit of the flags in authData is set.\n133:         if (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UP != AUTH_DATA_FLAGS_UP) {\n134:             return false;\n135:         }\n136: \n137:         // 17. If user verification is required for this assertion, verify that the User Verified bit of the flags in authData is set.\n138:         if (requireUV && (webAuthnAuth.authenticatorData[32] & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV) {\n139:             return false;\n140:         }\n141: \n142:         // skip 18.\n143: \n144:         // 19. Let hash be the result of computing a hash over the cData using SHA-256.\n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON));\n146: \n147:         // 20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData and hash.\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash));\n149:         bytes memory args = abi.encode(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n150:         // try the RIP-7212 precompile address\n151:         (bool success, bytes memory ret) = VERIFIER.staticcall(args);\n152:         // staticcall will not revert if address has no code\n153:         // check return length\n154:         // note that even if precompile exists, ret.length is 0 when verification returns false\n155:         // so an invalid signature will be checked twice: once by the precompile and once by FCL.\n156:         // Ideally this signature failure is simulated offchain and no one actually pay this gas.\n157:         bool valid = ret.length > 0;\n158:         if (success && valid) return abi.decode(ret, (uint256)) == 1;\n159: \n160:         return FCL.ecdsa_verify(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y);\n161:     }\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L161)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Stack variable is only used once",
      "description": "If the variable is only accessed once, it's cheaper to use the assigned value directly that one time, and save the 3 gas the extra stack assignment would spend.",
      "gasSavings": 3,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n61:         uint256 scalar_u = mulmod(uint256(message), sInv, n); \n62:         uint256 scalar_v = mulmod(r, sInv, n);\n83:             uint256 LHS = mulmod(y, y, p); // y^2 \n```\n",
          "loc": [
            "[61](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L61-L62)",
            "[83](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L83-L83)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n127:         bool sigFailed = !isValidWithdrawSignature(userOp.sender, withdrawRequest); \n```\n",
          "loc": [
            "[127](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L127-L127)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n308:             address owner; \n319:             WebAuthn.WebAuthnAuth memory auth = abi.decode(sigWrapper.signatureData, (WebAuthn.WebAuthnAuth)); \n```\n",
          "loc": [
            "[308](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L308-L308)",
            "[319](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L319-L319)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n116:         string memory _type = webAuthnAuth.clientDataJSON.slice(webAuthnAuth.typeIndex, webAuthnAuth.typeIndex + 21); \n123:         string memory actualChallenge = webAuthnAuth.clientDataJSON.slice( \n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON)); \n149:         bytes memory args = abi.encode(messageHash, webAuthnAuth.r, webAuthnAuth.s, x, y); \n157:         bool valid = ret.length > 0; \n```\n",
          "loc": [
            "[116](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L116-L116)",
            "[123](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L123-L123)",
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L145-L145)",
            "[149](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L149-L149)",
            "[157](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L157-L157)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "State variables should be cached in stack variables rather than re-reading them from storage",
      "description": "When performing multiple operations on a state variable in a function, it is recommended to cache it first. Either multiple reads or multiple writes to a state variable can save gas by caching it on the stack. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses. *Saves 100 gas per instance*.",
      "gasSavings": 100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit _withdrawableETH: 2 reads \n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost) \n144:         external\n145:         onlyEntryPoint\n146:     {\n/// @audit _withdrawableETH: 2 reads \n169:     function withdrawGasExcess() external { \n```\n",
          "loc": [
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L143-L146)",
            "[169](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L169-L169)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Struct can be reordered to fit into fewer storage slots",
      "description": "In Solidity, data type packing within struct variables is a recommended practice to optimize gas usage and efficiency in smart contracts.\n\nThis technique leverages the fact that Ethereum‚Äôs storage model stores variables in slots, with each slot offering a capacity of 32 bytes. When data types that consume less than 32 bytes, such as **uint8**, **bool**, or **address**, are declared individually, each occupies a whole storage slot. However, when these smaller variables are grouped into a struct, they can share a storage slot, resulting in a significant reduction in storage requirements and, by extension, gas costs.",
      "gasSavings": 20000,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit use this order:  signature, amount, nonce, asset, expiry\n/// @audit 1 storage slot(s) saved, (before 5, after 4)\n20:     struct WithdrawRequest { \n```\n",
          "loc": [
            "[20](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L20-L20)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "The result of a function call should be cached rather than re-calling the function",
      "description": "External calls are expensive. Results of external function calls should be cached rather than call them multiple times. Consider caching the following:",
      "gasSavings": 50,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit _getMultiOwnableStorage called on lines 192, 193\n189:     function _addOwnerAtIndex(bytes memory owner, uint256 index) internal virtual { \n190:         if (isOwnerBytes(owner)) revert AlreadyOwner(owner);\n191: \n192:         _getMultiOwnableStorage().isOwner[owner] = true;\n193:         _getMultiOwnableStorage().ownerAtIndex[index] = owner;\n194: \n195:         emit AddOwner(index, owner);\n196:     }\n```\n",
          "loc": [
            "[189](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L189-L196)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "description": "Citing the [documentation](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html):\n\n> When using elements that are smaller than 32 bytes, your contract‚Äôs gas usage may be higher.This is because the EVM operates on 32 bytes at a time.Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nFor example, each operation involving a `uint8` costs an extra ** 22 - 28 gas ** (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving`uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the`uint8`, as well as the associated stack operations of doing so.\n\nConsider using a larger size, then downcast where needed.",
      "gasSavings": 6,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n30:         uint48 expiry; \n232:     function entryPointAddStake(uint256 amount, uint32 unstakeDelaySeconds) external payable onlyOwner { \n```\n",
          "loc": [
            "[30](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L30)",
            "[232](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L232)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use `Array.unsafeAccess()` to avoid repeated array length checks",
      "description": "When using storage arrays, solidity adds an internal lookup of the array's length (a Gcoldsload **2100 gas**) to ensure you don't read past the array's end. You can avoid this lookup by using [`Array.unsafeAccess()`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/94697be8a3f0dfcd95dfb13ffbd39b5973f5c65d/contracts/utils/Arrays.sol#L57) in cases where the length has already been checked, as is the case with the instances below",
      "gasSavings": 2100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n207:             _call(calls[i].target, calls[i].value, calls[i].data); \n```\n",
          "loc": [
            "[207](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L207-L207)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n164:             if (owners[i].length != 32 && owners[i].length != 64) { \n165:                 revert InvalidOwnerBytesLength(owners[i]);\n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n169:                 revert InvalidEthereumAddressOwner(owners[i]);\n172:             _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++); \n```\n",
          "loc": [
            "[164](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L164-L165)",
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L169)",
            "[172](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L172-L172)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly for small `keccak256` hashes, in order to save gas",
      "description": "The assembly version of the keccak256 hashing function can be more gas efficient than the high-level Solidity version.",
      "gasSavings": 80,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n235:         return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint())); \n```\n",
          "loc": [
            "[235](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L235-L235)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n102:         return keccak256( \n103:             abi.encode(\n104:                 keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n105:                 keccak256(bytes(name)),\n106:                 keccak256(bytes(version)),\n107:                 block.chainid,\n108:                 address(this)\n109:             )\n110:         );\n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash))); \n134:         return keccak256(abi.encode(_MESSAGE_TYPEHASH, hash)); \n```\n",
          "loc": [
            "[102](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L102-L110)",
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L122-L122)",
            "[134](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L134-L134)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n117:         if (keccak256(bytes(_type)) != EXPECTED_TYPE_HASH) { \n126:         if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) { \n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L117-L117)",
            "[126](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L126-L126)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly in place of `abi.decode` to save gas",
      "description": "Instead of using abi.decode, we can use assembly to decode our desired calldata values directly. This will allow us to avoid decoding calldata values that we will not use.",
      "gasSavings": 112,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n114:         WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest)); \n152:         (uint256 maxGasCost, address account) = abi.decode(context, (uint256, address)); \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L114-L114)",
            "[152](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L152-L152)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n298:         SignatureWrapper memory sigWrapper = abi.decode(signature, (SignatureWrapper)); \n317:             (uint256 x, uint256 y) = abi.decode(ownerBytes, (uint256, uint256)); \n319:             WebAuthn.WebAuthnAuth memory auth = abi.decode(sigWrapper.signatureData, (WebAuthn.WebAuthnAuth)); \n```\n",
          "loc": [
            "[298](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L298-L298)",
            "[317](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L317-L317)",
            "[319](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L319-L319)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n158:         if (success && valid) return abi.decode(ret, (uint256)) == 1; \n```\n",
          "loc": [
            "[158](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L158-L158)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly scratch space to build calldata for external calls",
      "description": "Using Solidity's assembly scratch space for constructing calldata in external calls with one or two arguments can be a gas-efficient approach. This method leverages the designated memory area (the first 64 bytes of memory) for temporary data storage during assembly operations. By directly writing arguments into this scratch space, it eliminates the need for additional memory allocation typically required for calldata preparation. This technique can lead to notable gas savings, especially in high-frequency or gas-sensitive operations. However, it requires careful implementation to avoid data corruption and should be used with a thorough understanding of low-level EVM operations and memory handling. Proper testing and validation are crucial when employing such optimizations.",
      "gasSavings": 220,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n223:         IEntryPoint(entryPoint()).withdrawTo(to, amount); \n233:         IEntryPoint(entryPoint()).addStake{value: amount}(unstakeDelaySeconds); \n249:         IEntryPoint(entryPoint()).withdrawStake(to); \n```\n",
          "loc": [
            "[223](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L223-L223)",
            "[233](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L233-L233)",
            "[249](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L249-L249)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n54:             account.initialize(owners); \n```\n",
          "loc": [
            "[54](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L54-L54)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use assembly to validate `msg.sender`",
      "description": "We can use assembly to efficiently validate msg.sender with the least amount of opcodes necessary. For more details check the following report [Here](https://code4rena.com/reports/2023-05-juicebox#g-06-use-assembly-to-validate-msgsender)",
      "gasSavings": 12,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n184:         if (!isValidWithdrawSignature(msg.sender, withdrawRequest)) { \n```\n",
          "loc": [
            "[184](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L184-L184)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n202:         if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) { \n```\n",
          "loc": [
            "[202](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L202-L202)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use `assembly` to write address/contract storage values",
      "description": "Using `assembly { sstore(state.slot, addr) }` instead of `state = addr` can save gas.",
      "gasSavings": 50,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n25:         implementation = erc4337; \n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this)); \n```\n",
          "loc": [
            "[25](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L25-L25)",
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L65-L65)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n53:         verifyingContract = address(this); \n```\n",
          "loc": [
            "[53](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L53-L53)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use `calldata` instead of `memory` for function arguments that do not get mutated",
      "description": "Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.",
      "gasSavings": 300,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit withdrawRequest\n181:     function withdraw(WithdrawRequest memory withdrawRequest) external { \n/// @audit withdrawRequest\n260:     function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest) \n261:         public\n262:         view\n263:         returns (bool)\n264:     {\n/// @audit withdrawRequest\n279:     function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) { \n```\n",
          "loc": [
            "[181](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L181-L181)",
            "[260](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L260-L264)",
            "[279](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L279-L279)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit account\n136:     function isOwnerBytes(bytes memory account) public view virtual returns (bool) { \n```\n",
          "loc": [
            "[136](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L136-L136)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use constants instead of `type(uint<n>).max` / `.min`",
      "description": "_",
      "gasSavings": 4,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n302:             if (uint256(bytes32(ownerBytes)) > type(uint160).max) { \n```\n",
          "loc": [
            "[302](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L302-L302)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n```\n",
          "loc": [
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use scratch space when building emitted events with two data arguments",
      "description": "We can use assembly to emit events efficiently by utilizing `scratch space` and the `free memory pointer`. This will allow us to potentially avoid memory expansion costs.\nNote: In order to do this optimization safely, we will need to cache and restore the free memory pointer.\n\nFor example, for a generic `emit` event for `eventSentAmountExample`: \n```solidity\n// uint256 id, uint256 value, uint256 amount\nemit eventSentAmountExample(id, value, amount);\n```\n",
      "gasSavings": 38,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n109:         emit RemoveOwner(index, owner); \n195:         emit AddOwner(index, owner); \n```\n",
          "loc": [
            "[109](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L109)",
            "[195](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L195)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use `selfbalance()` instead of `address(this).balance`",
      "description": "Use assembly when getting a contract's balance of ETH.\n\nYou can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas.\nAdditionally, you can use `balance(address)` instead of `address().balance` when getting an external contract's balance of ETH.\n\n*Saves 15 gas when checking internal balance, 6 for external*",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n133:         if (address(this).balance < withdrawAmount) { \n134:             revert InsufficientBalance(withdrawAmount, address(this).balance);\n```\n",
          "loc": [
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L133-L134)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use shift right/left instead of division/multiplication if possible",
      "description": "`<x> * 2` is the same as `<x> << 1`. While the compiler uses the `SHL` opcode to accomplish both, the version that uses multiplication incurs an overhead of **20 gas** due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.",
      "gasSavings": 20,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n47:     uint256 private constant P256_N_DIV_2 = FCL.n / 2; \n```\n",
          "loc": [
            "[47](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L47)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Use `uint256(1)`/`uint256(2)` instead of `true`/`false` to save gas for changes",
      "description": "Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‚Äòfalse‚Äô to ‚Äòtrue‚Äô, after having been ‚Äòtrue‚Äô in the past. Refer to the [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ae630684a0f57de400ef69499addab4c32ac8fb/contracts/security/ReentrancyGuard.sol#L23-L27).",
      "gasSavings": 17100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n37:     mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed; \n```\n",
          "loc": [
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L37-L37)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using `private` rather than `public`, saves gas",
      "description": "For constants, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves 3406-3606 gas in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table",
      "gasSavings": 3606,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n43:     uint256 public constant REPLAYABLE_NONCE_KEY = 8453; \n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L43-L43)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n15:     address public immutable implementation; \n```\n",
          "loc": [
            "[15](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L15-L15)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "Using `storage` instead of `memory` for structs/arrays saves gas",
      "description": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct",
      "gasSavings": 2100,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n114:         WithdrawRequest memory withdrawRequest = abi.decode(userOp.paymasterAndData[20:], (WithdrawRequest)); \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L114-L114)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n104:         bytes[] memory owners = new bytes[](1); \n298:         SignatureWrapper memory sigWrapper = abi.decode(signature, (SignatureWrapper)); \n319:             WebAuthn.WebAuthnAuth memory auth = abi.decode(sigWrapper.signatureData, (WebAuthn.WebAuthnAuth)); \n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L104-L104)",
            "[298](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L298-L298)",
            "[319](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L319-L319)"
          ]
        }
      ]
    },
    {
      "severity": "Gas",
      "title": "x + y is more efficient than using += for state variables (likewise for -=)",
      "description": "In instances found where either += or -= are used against state variables use x = x + y instead",
      "gasSavings": 248,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n138:         _withdrawableETH[userOp.sender] += withdrawAmount - maxCost; \n```\n",
          "loc": [
            "[138](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L138)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "File allows a version of solidity that is susceptible to `.selector`-related optimizer bug",
      "description": "File uses a version of solidity that is susceptible to `.selector`-related optimizer bug, but does not use `.selector`.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n24: pragma solidity >=0.8.19 <0.9.0; \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L24-L24)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n2: pragma solidity 0.8.23; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L2-L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L2-L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L2-L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n2: pragma solidity ^0.8.4; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L2-L2)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n2: pragma solidity ^0.8.0; \n```\n",
          "loc": [
            "[2](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L2-L2)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Functions contain the same code",
      "description": "The rule is valid, but the following findings are invalid.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n294:         return (y == 0);\n295:     }\n```\n",
          "loc": [
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L295)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n260:     function isValidWithdrawSignature(address account, WithdrawRequest memory withdrawRequest) \n261:         public\n262:         view\n263:         returns (bool)\n264:     {\n265:         return SignatureCheckerLib.isValidSignatureNow(\n266:             owner(), getHash(account, withdrawRequest), withdrawRequest.signature\n267:         );\n268:     }\n279:     function getHash(address account, WithdrawRequest memory withdrawRequest) public view returns (bytes32) { \n280:         return SignatureCheckerLib.toEthSignedMessageHash(\n281:             abi.encode(\n282:                 address(this),\n283:                 account,\n284:                 block.chainid,\n285:                 withdrawRequest.asset,\n286:                 withdrawRequest.amount,\n287:                 withdrawRequest.nonce,\n288:                 withdrawRequest.expiry\n289:             )\n290:         );\n291:     }\n299:     function nonceUsed(address account, uint256 nonce) external view returns (bool) { \n300:         return _nonceUsed[nonce][account];\n301:     }\n304:     function entryPoint() public pure returns (address) { \n305:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n306:     }\n```\n",
          "loc": [
            "[260](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L260-L268)",
            "[279](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L279-L291)",
            "[299](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L299-L301)",
            "[304](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L304-L306)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n217:     function entryPoint() public view virtual returns (address) { \n218:         return 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789;\n219:     }\n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n235:         return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint()));\n236:     }\n333:     function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) { \n334:         return (\"Coinbase Smart Wallet\", \"1\");\n335:     }\n```\n",
          "loc": [
            "[217](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L217-L219)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L236)",
            "[333](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L333-L335)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n90:     function replaySafeHash(bytes32 hash) public view virtual returns (bytes32) { \n91:         return _eip712Hash(hash);\n92:     }\n121:     function _eip712Hash(bytes32 hash) internal view virtual returns (bytes32) { \n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash)));\n123:     }\n133:     function _hashStruct(bytes32 hash) internal view virtual returns (bytes32) { \n134:         return keccak256(abi.encode(_MESSAGE_TYPEHASH, hash));\n135:     }\n```\n",
          "loc": [
            "[90](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L90-L92)",
            "[121](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L121-L123)",
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L133-L135)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n117:     function isOwnerAddress(address account) public view virtual returns (bool) { \n118:         return _getMultiOwnableStorage().isOwner[abi.encode(account)];\n119:     }\n127:     function isOwnerPublicKey(bytes32 x, bytes32 y) public view virtual returns (bool) { \n128:         return _getMultiOwnableStorage().isOwner[abi.encode(x, y)];\n129:     }\n136:     function isOwnerBytes(bytes memory account) public view virtual returns (bool) { \n137:         return _getMultiOwnableStorage().isOwner[account];\n138:     }\n145:     function ownerAtIndex(uint256 index) public view virtual returns (bytes memory) { \n146:         return _getMultiOwnableStorage().ownerAtIndex[index];\n147:     }\n152:     function nextOwnerIndex() public view virtual returns (uint256) { \n153:         return _getMultiOwnableStorage().nextOwnerIndex;\n154:     }\n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L117-L119)",
            "[127](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L127-L129)",
            "[136](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L136-L138)",
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L145-L147)",
            "[152](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L152-L154)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Inline `modifier`s that are only used once, to save gas",
      "description": "Inlining modifiers does not save gas",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n91:     modifier payPrefund(uint256 missingAccountFunds) virtual { \n92:         _;\n93: \n94:         assembly (\"memory-safe\") {\n95:             if missingAccountFunds {\n96:                 // Ignore failure (it's EntryPoint's job to verify, not the account's).\n97:                 pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n98:             }\n99:         }\n100:     }\n```\n",
          "loc": [
            "[91](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L91-L100)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "State variable read in a loop",
      "description": "These references to the variable cannot be cached, or that are 'constant' / 'immutable'",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n169:                     T1 := mulmod(T1, T2, p) // W=UV \n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1 \n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S \n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n183:                             Y := sub(p, Y) //restore the -Y inversion \n188:                             T1 := gx \n189:                             T2 := gy\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P \n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free \n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n221:                                 T1 := mulmod(T1, T2, p) // W=UV \n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1 \n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S \n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1 \n237:                         T4 := mulmod(T2, T2, p) //PP \n239:                         zz := mulmod(zz, T4, p) \n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p) \n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n```\n",
          "loc": [
            "[169](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L169-L169)",
            "[171](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L171-L172)",
            "[174](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L174-L176)",
            "[183](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L183-L183)",
            "[188](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L188-L189)",
            "[211](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L211-L211)",
            "[217](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L217-L219)",
            "[221](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L221-L223)",
            "[225](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L225-L226)",
            "[228](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L228-L229)",
            "[231](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L231-L231)",
            "[237](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L237-L237)",
            "[239](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L239-L240)",
            "[242](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L242-L243)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "`++i` costs less gas than `i++`, especially when it's used in for-loops (`--i`/`i--` too)",
      "description": "Changing to a pre-increment for the examples below will break the code",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n172:             _addOwnerAtIndex(owners[i], _getMultiOwnableStorage().nextOwnerIndex++); \n180:         _addOwnerAtIndex(owner, _getMultiOwnableStorage().nextOwnerIndex++); \n```\n",
          "loc": [
            "[172](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L172-L172)",
            "[180](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L180-L180)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "All interfaces used within a project should be imported",
      "description": "These contracts don't rely on other contracts for their definitions, so there's nothing to import",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n26: library FCL { \n```\n",
          "loc": [
            "[26](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L26)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n13: contract CoinbaseSmartWalletFactory { \n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n16: abstract contract ERC1271 { \n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L16)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n32: contract MultiOwnable { \n```\n",
          "loc": [
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L32)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n18: library WebAuthn { \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L18)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Array lengths not checked",
      "description": "These instances only have one array",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n114:     function initialize(bytes[] calldata owners) public payable virtual { \n205:     function executeBatch(Call[] calldata calls) public payable virtual onlyEntryPointOrOwner { \n```\n",
          "loc": [
            "[114](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L114-L114)",
            "[205](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L205-L205)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n38:     function createAccount(bytes[] calldata owners, uint256 nonce) \n39:         public\n40:         payable\n41:         virtual\n42:         returns (CoinbaseSmartWallet account)\n43:     {\n64:     function getAddress(bytes[] calldata owners, uint256 nonce) external view returns (address predicted) { \n81:     function _getSalt(bytes[] calldata owners, uint256 nonce) internal pure returns (bytes32 salt) { \n```\n",
          "loc": [
            "[38](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L38-L43)",
            "[64](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L64-L64)",
            "[81](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L81-L81)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n162:     function _initializeOwners(bytes[] memory owners) internal virtual { \n```\n",
          "loc": [
            "[162](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L162-L162)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Assembly blocks should have comments",
      "description": "These blocks already have comments",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n324:             assembly { \n325:                 P0 := mulmod(2, y, p) //U = 2*Y1\n326:                 P2 := mulmod(P0, P0, p) // V=U^2\n327:                 P3 := mulmod(x, P2, p) // S = X1*V\n328:                 P1 := mulmod(P0, P2, p) // W=UV\n329:                 P2 := mulmod(P2, zz, p) //zz3=V*ZZ1\n330:                 zz := mulmod(3, mulmod(addmod(x, sub(p, zz), p), addmod(x, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n331:                 P0 := addmod(mulmod(zz, zz, p), mulmod(minus_2, P3, p), p) //X3=M^2-2S\n332:                 x := mulmod(zz, addmod(P3, sub(p, P0), p), p) //M(S-X3)\n333:                 P3 := mulmod(P1, zzz, p) //zzz3=W*zzz1\n334:                 P1 := addmod(x, sub(p, mulmod(P1, y, p)), p) //Y3= M(S-X3)-W*Y1\n335:             }\n354:             assembly { \n355:                 y1 := sub(p, y1)\n356:                 y2 := addmod(mulmod(y2, zzz1, p), y1, p)\n357:                 x2 := addmod(mulmod(x2, zz1, p), sub(p, x1), p)\n358:                 P0 := mulmod(x2, x2, p) //PP = P^2\n359:                 P1 := mulmod(P0, x2, p) //PPP = P*PP\n360:                 P2 := mulmod(zz1, P0, p) ////ZZ3 = ZZ1*PP\n361:                 P3 := mulmod(zzz1, P1, p) ////ZZZ3 = ZZZ1*PPP\n362:                 zz1 := mulmod(x1, P0, p) //Q = X1*PP\n363:                 P0 := addmod(addmod(mulmod(y2, y2, p), sub(p, P1), p), mulmod(minus_2, zz1, p), p) //R^2-PPP-2*Q\n364:                 P1 := addmod(mulmod(addmod(zz1, sub(p, P0), p), y2, p), mulmod(y1, P1, p), p) //R*(Q-X3)\n365:             }\n```\n",
          "loc": [
            "[324](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L324-L335)",
            "[354](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L354-L365)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Avoid double casting",
      "description": "The rule is valid, but the following findings are invalid.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n51:         account = CoinbaseSmartWallet(payable(accountAddress)); \n```\n",
          "loc": [
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L51-L51)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Consider adding a block/deny-list",
      "description": "Contract doesn't handle tokens",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n13: contract CoinbaseSmartWalletFactory { \n14:     /// @notice Address of the ERC-4337 implementation used as implementation for new accounts.\n15:     address public immutable implementation;\n16: \n17:     /// @notice Thrown when trying to create a new `CoinbaseSmartWallet` account without any owner.\n18:     error OwnerRequired();\n19: \n20:     /// @notice Factory constructor used to initialize the implementation address to use for future\n21:     ///         ERC-4337 account deployments.\n22:     ///\n23:     /// @param erc4337 The address of the ERC-4337 implementation used to deploy new cloned accounts.\n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L13-L23)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n16: abstract contract ERC1271 { \n17:     /// @dev Precomputed `typeHash` used to produce EIP-712 compliant hash when applying the anti\n18:     ///      cross-account-replay layer.\n19:     ///\n20:     ///      The original hash must either be:\n21:     ///         - An EIP-191 hash: keccak256(\"\\x19Ethereum Signed Message:\\n\" || len(someMessage) || someMessage)\n22:     ///         - An EIP-712 hash: keccak256(\"\\x19\\x01\" || someDomainSeparator || hashStruct(someStruct))\n23:     bytes32 private constant _MESSAGE_TYPEHASH = keccak256(\"CoinbaseSmartWalletMessage(bytes32 hash)\");\n24: \n25:     /// @notice Returns information about the `EIP712Domain` used to create EIP-712 compliant hashes.\n26:     ///\n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L16-L26)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n32: contract MultiOwnable { \n33:     /// @dev Slot for the `MultiOwnableStorage` struct in storage.\n34:     ///      Computed from: keccak256(abi.encode(uint256(keccak256(\"coinbase.storage.MultiOwnable\")) - 1)) & ~bytes32(uint256(0xff))\n35:     ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201).\n36:     bytes32 private constant MUTLI_OWNABLE_STORAGE_LOCATION =\n37:         0x97e2c6aad4ce5d562ebfaa00db6b9e0fb66ea5d8162ed5b243f51a2e03086f00;\n38: \n39:     /// @notice Thrown when the sender is not an owner and is trying to call a privileged function.\n40:     error Unauthorized();\n41: \n42:     /// @notice Thrown when trying to add an already registered owner.\n```\n",
          "loc": [
            "[32](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L32-L42)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Consider merging sequential for loops",
      "description": "The general rule is valid, but the instances below are invalid",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n206:         for (uint256 i; i < calls.length;) { \n```\n",
          "loc": [
            "[206](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L206-L206)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n163:         for (uint256 i; i < owners.length; i++) { \n```\n",
          "loc": [
            "[163](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L163-L163)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Default `bool` values are manually reset",
      "description": "Using delete instead of assigning zero/false to state variables does not save any extra gas with the optimizer [on](https://gist.github.com/IllIllI000/ef8ec3a70aede7f12433fe63dc418515#with-the-optimizer-set-at-200-runs) (saves 5-8 gas with optimizer completely off), so this finding is invalid, especially since if they were interested in gas savings, they'd have the optimizer enabled. Some bots are also flagging `true` rather than just `false`",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n320:         _nonceUsed[withdrawRequest.nonce][account] = true; \n```\n",
          "loc": [
            "[320](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L320-L320)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n192:         _getMultiOwnableStorage().isOwner[owner] = true; \n```\n",
          "loc": [
            "[192](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L192-L192)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Event names should use CamelCase",
      "description": "The instances below are already CamelCase (events are supposed to use CamelCase, not lowerCamelCase).",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n45:     event MagicSpendWithdrawal(address indexed account, address indexed asset, uint256 amount, uint256 nonce); \n```\n",
          "loc": [
            "[45](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L45-L45)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n68:     event AddOwner(uint256 indexed index, bytes owner); \n74:     event RemoveOwner(uint256 indexed index, bytes owner); \n```\n",
          "loc": [
            "[68](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L68-L68)",
            "[74](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L74-L74)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Function can be declared as `pure`",
      "description": "The general rule is valid, but the instances below are invalid",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit contains sload\n                  } call\n241:     function implementation() public view returns (address $) { \n```\n",
          "loc": [
            "[241](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L241-L241)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Function definition modifier order does not follow Solidity style guide",
      "description": "This rule does not apply to internal library functions, so these instances are invalid.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n50:     function ecdsa_verify(bytes32 message, uint256 r, uint256 s, uint256 Qx, uint256 Qy) internal view returns (bool) { \n78:     function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) { \n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n274:     function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) { \n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n301:     function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n302:         internal\n303:         view\n304:         returns (uint256 x1, uint256 y1)\n305:     {\n318:     function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz) \n319:         internal\n320:         pure\n321:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n322:     {\n344:     function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2) \n345:         internal\n346:         pure\n347:         returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\n348:     {\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n```\n",
          "loc": [
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L50-L50)",
            "[78](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L78-L78)",
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L94)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L122)",
            "[274](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L274-L274)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L293)",
            "[301](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L301-L305)",
            "[318](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L318-L322)",
            "[344](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L344-L348)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L374)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n104:     function verify(bytes memory challenge, bool requireUV, WebAuthnAuth memory webAuthnAuth, uint256 x, uint256 y) \n105:         internal\n106:         view\n107:         returns (bool)\n108:     {\n```\n",
          "loc": [
            "[104](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L104-L108)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Functions missing NatSpec `@param` tag",
      "description": "_",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n108:     /// @inheritdoc IPaymaster \n109:     function validatePaymasterUserOp(UserOperation calldata userOp, bytes32, uint256 maxCost)\n142:     /// @inheritdoc IPaymaster \n143:     function postOp(IPaymaster.PostOpMode mode, bytes calldata context, uint256 actualGasCost)\n```\n",
          "loc": [
            "[108](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L108-L109)",
            "[142](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L142-L143)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n327:     /// @inheritdoc UUPSUpgradeable \n328:     ///\n329:     /// @dev Authorization logic is only based on the sender being an owner of this account.\n330:     function _authorizeUpgrade(address) internal view virtual override(UUPSUpgradeable) onlyOwner {}\n332:     /// @inheritdoc ERC1271 \n333:     function _domainNameAndVersion() internal pure override(ERC1271) returns (string memory, string memory) {\n```\n",
          "loc": [
            "[327](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L327-L330)",
            "[332](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L332-L333)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Inconsistent comment spacing",
      "description": "URLs are not comments",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n21: // Abstract: https://eprint.iacr.org/2023/939.pdf \n22: // Github code: https://github.com/rdubois-crypto/FreshCryptoLib/blob/d9bb3b0fc6b737af2c70dab246cabbc7d05afc3c/solidity/src/FCL_ecdsa.sol#L40\n300:     /*    https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html#addition-add-2008-s*/ \n```\n",
          "loc": [
            "[21](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L21-L22)",
            "[300](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L300)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n13: /// @author Coinbase (https://github.com/coinbase/magic-spend) \n17: /// @dev See https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters. \n273:     ///      https://eips.ethereum.org/EIPS/eip-191. \n```\n",
          "loc": [
            "[13](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L13)",
            "[17](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L17)",
            "[273](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L273)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n18: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n19: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337.sol)\n267:     /// @dev Impl taken from https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L347 \n```\n",
          "loc": [
            "[18](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L18-L19)",
            "[267](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L267)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n11: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n12: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337Factory.sol)\n```\n",
          "loc": [
            "[11](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L11-L12)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n14: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n15: /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)\n27:     /// @dev Follows ERC-5267 (see https://eips.ethereum.org/EIPS/eip-5267). \n60:     /// @dev This implementation follows ERC-1271. See https://eips.ethereum.org/EIPS/eip-1271. \n97:     ///      See https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator. \n116:     /// @dev See https://eips.ethereum.org/EIPS/eip-712#specification. \n128:     /// @dev See https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct. \n```\n",
          "loc": [
            "[14](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L14-L15)",
            "[27](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L27)",
            "[60](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L60)",
            "[97](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L97)",
            "[116](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L116)",
            "[128](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L128)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n31: /// @author Coinbase (https://github.com/coinbase/smart-wallet) \n35:     ///      Follows ERC-7201 (see https://eips.ethereum.org/EIPS/eip-7201). \n```\n",
          "loc": [
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L31)",
            "[35](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L35)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n16: /// @author Coinbase (https://github.com/base-org/webauthn-sol) \n17: /// @author Daimo (https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol)\n23:         ///      See https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata. \n26:         ///      See https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson. \n39:     ///      See https://www.w3.org/TR/webauthn-2/#flags. \n43:     ///      See https://www.w3.org/TR/webauthn-2/#flags. \n50:     ///      See https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md. \n54:     ///      See https://www.w3.org/TR/webauthn-2/#dom-collectedclientdata-type \n59:     /// in https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion. \n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L16-L17)",
            "[23](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L23)",
            "[26](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L26)",
            "[39](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L39)",
            "[43](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L43)",
            "[50](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L50)",
            "[54](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L54)",
            "[59](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L59)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Integer increments by one can be unchecked to save on gas fees",
      "description": "The instances below are already in an unchecked block.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n209:                 ++i; \n```\n",
          "loc": [
            "[209](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L209-L209)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Low level calls with Solidity before `0.8.14` result in an optimiser bug",
      "description": "This assembly block does not call `mstore()`, so it's not possible to hit the bug here even if there are small future changes, so this doesn't seem low severity.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n213:         assembly (\"memory-safe\") { \n214:             $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n215:         }\n```\n",
          "loc": [
            "[213](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L213-L215)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Magic numbers should be replaced with constants",
      "description": "The rule is valid, but the following findings are invalid.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n31:     uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF; \n33:     uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC; \n35:     uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B; \n37:     uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296; \n38:     uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n40:     uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551; \n42:     uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD; \n44:     uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F; \n46:     uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \n```\n",
          "loc": [
            "[31](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L31-L31)",
            "[33](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L33-L33)",
            "[35](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L35-L35)",
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L37-L38)",
            "[40](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L40-L40)",
            "[42](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L42-L42)",
            "[44](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L44-L44)",
            "[46](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L46-L46)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n43:     uint256 public constant REPLAYABLE_NONCE_KEY = 8453; \n```\n",
          "loc": [
            "[43](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L43-L43)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Misplaced SPDX identifier",
      "description": "It's already on the first line",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L1)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n1: // SPDX-License-Identifier: MIT \n```\n",
          "loc": [
            "[1](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L1)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Multiple mappings with same keys can be combined into a single struct mapping for readability",
      "description": "The general rule is valid, but the instances below are invalid",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n34:     mapping(address user => uint256 amount) internal _withdrawableETH; \n```\n",
          "loc": [
            "[34](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L34-L34)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Prefer double quotes for string quoting",
      "description": "The examples below are not strings. Furthermore it's perfectly reasonable to use single quotes within text ([p. 16](https://www.ox.ac.uk/sites/files/oxford/media_wysiwyg/University%20of%20Oxford%20Style%20Guide.pdf)).",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n5: // | _| '_/ -_|_-< ' \\  | (__| '_| || | '_ \\  _/ _ \\ | |__| | '_ \\ \n```\n",
          "loc": [
            "[5](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L5-L5)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n16: ///         with inspiration from Alchemy's LightAccount and Daimo's DaimoAccount. \n96:                 // Ignore failure (it's EntryPoint's job to verify, not the account's). \n```\n",
          "loc": [
            "[16](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L16)",
            "[96](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L96)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n76:     ///         - Does NOT verify that the origin in the `clientDataJSON` matches the Relying Party's origin: tt is considered \n```\n",
          "loc": [
            "[76](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L76)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Timestamp may be manipulation",
      "description": "Use of `block.timestamp`, in and of itself, is not evidence of an issue; there must be an incorrect usage in the code in order for there to be a vulnerability. There should also be a corresponding suggested fix.",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n188:         if (block.timestamp > withdrawRequest.expiry) { \n```\n",
          "loc": [
            "[188](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L188)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Unsafe downcast",
      "description": "When a type is downcast to a smaller type, the higher order bits are truncated, effectively applying a modulo to the original value. Without any other checks, this wrapping will lead to unexpected behavior and bugs",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit bytes32 -> uint256\n61:         uint256 scalar_u = mulmod(uint256(message), sInv, n); \n```\n",
          "loc": [
            "[61](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L61-L61)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit uint48 -> uint256\n128:         validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160); \n/// @audit contract MagicSpend -> address\n133:         if (address(this).balance < withdrawAmount) { \n/// @audit contract MagicSpend -> address\n134:             revert InsufficientBalance(withdrawAmount, address(this).balance);\n/// @audit contract MagicSpend -> address\n282:                 address(this), \n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L128-L128)",
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L133-L134)",
            "[282](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L282-L282)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit bytes calldata slice -> bytes4\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) { \n/// @audit bytes calldata slice -> bytes4\n181:         bytes4 selector = bytes4(data[0:4]); \n/// @audit contract CoinbaseSmartWallet -> address\n186:         _call(address(this), 0, data); \n/// @audit bytes32 -> uint256\n/// @audit bytes memory -> bytes32\n302:             if (uint256(bytes32(ownerBytes)) > type(uint160).max) { \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L148-L148)",
            "[181](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L181-L181)",
            "[186](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L186-L186)",
            "[302](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L302-L302)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit address -> address\n51:         account = CoinbaseSmartWallet(payable(accountAddress)); \n/// @audit contract CoinbaseSmartWalletFactory -> address\n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this)); \n```\n",
          "loc": [
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L51-L51)",
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L65-L65)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit contract ERC1271 -> address\n53:         verifyingContract = address(this); \n/// @audit string memory -> bytes\n105:                 keccak256(bytes(name)), \n/// @audit string memory -> bytes\n106:                 keccak256(bytes(version)),\n/// @audit contract ERC1271 -> address\n108:                 address(this) \n```\n",
          "loc": [
            "[53](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L53-L53)",
            "[105](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L105-L106)",
            "[108](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L108-L108)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit bytes32 -> uint256\n/// @audit bytes memory -> bytes32\n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n/// @audit contract MultiOwnable -> address\n202:         if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) { \n```\n",
          "loc": [
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)",
            "[202](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L202-L202)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit string memory -> bytes\n117:         if (keccak256(bytes(_type)) != EXPECTED_TYPE_HASH) { \n/// @audit string memory -> bytes\n122:         bytes memory expectedChallenge = bytes(string.concat('\"challenge\":\"', Base64.encodeURL(challenge), '\"')); \n/// @audit string memory -> bytes\n126:         if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) { \n/// @audit string memory -> bytes\n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON)); \n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L117-L117)",
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L122-L122)",
            "[126](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L126-L126)",
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L145-L145)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Unused named return variables without optimizer waste gas",
      "description": "Suggestions that only apply when the optimizer is _off_ are not useful to sponsors. Why would they pay for gas optimizations if they don't have the optimizer on, and don't plan to turn it on? Only a [small minority](https://github.com/search?q=org%3Acode-423n4+%22optimizer+%3D+false%22&type=code) have the optimizer off; the majority have it set to more than [200](https://github.com/search?q=org%3Acode-423n4+optimizer_runs&type=code) runs",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n94:     function FCL_nModInv(uint256 u) internal view returns (uint256 result) { \n95:         assembly {\n96:             let pointer := mload(0x40)\n97:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n98:             mstore(pointer, 0x20)\n99:             mstore(add(pointer, 0x20), 0x20)\n100:             mstore(add(pointer, 0x40), 0x20)\n101:             // Define variables base, exponent and modulus\n102:             mstore(add(pointer, 0x60), u)\n103:             mstore(add(pointer, 0x80), minus_2modn)\n104:             mstore(add(pointer, 0xa0), n)\n105: \n106:             // Call the precompiled contract 0x05 = ModExp\n107:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n108:             result := mload(pointer)\n109:         }\n110:     }\n117:     function ecZZ_mulmuladd_S_asm( \n118:         uint256 Q0,\n119:         uint256 Q1, //affine rep for input point Q\n120:         uint256 scalar_u,\n121:         uint256 scalar_v\n122:     ) internal view returns (uint256 X) {\n123:         uint256 zz;\n124:         uint256 zzz;\n125:         uint256 Y;\n126:         uint256 index = 255;\n127:         uint256 H0;\n128:         uint256 H1;\n129: \n130:         unchecked {\n131:             if (scalar_u == 0 && scalar_v == 0) return 0;\n132: \n133:             (H0, H1) = ecAff_add(gx, gy, Q0, Q1);\n134:             if (\n135:                 (H0 == 0) && (H1 == 0) //handling Q=-G\n136:             ) {\n137:                 scalar_u = addmod(scalar_u, n - scalar_v, n);\n138:                 scalar_v = 0;\n139:             }\n140:             assembly {\n141:                 for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\n142:                     index := sub(index, 1)\n143:                     T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n144:                 } {}\n145:                 zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n146: \n147:                 if eq(zz, 1) {\n148:                     X := gx\n149:                     Y := gy\n150:                 }\n151:                 if eq(zz, 2) {\n152:                     X := Q0\n153:                     Y := Q1\n154:                 }\n155:                 if eq(zz, 3) {\n156:                     X := H0\n157:                     Y := H1\n158:                 }\n159: \n160:                 index := sub(index, 1)\n161:                 zz := 1\n162:                 zzz := 1\n163: \n164:                 for {} gt(minus_1, index) { index := sub(index, 1) } {\n165:                     // inlined EcZZ_Dbl\n166:                     let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\n167:                     let T2 := mulmod(T1, T1, p) // V=U^2\n168:                     let T3 := mulmod(X, T2, p) // S = X1*V\n169:                     T1 := mulmod(T1, T2, p) // W=UV\n170:                     let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\n171:                     zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n172:                     zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n173: \n174:                     X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n175:                     T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\n176:                     Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\n177: \n178:                     {\n179:                         //value of dibit\n180:                         T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\n181: \n182:                         if iszero(T4) {\n183:                             Y := sub(p, Y) //restore the -Y inversion\n184:                             continue\n185:                         } // if T4!=0\n186: \n187:                         if eq(T4, 1) {\n188:                             T1 := gx\n189:                             T2 := gy\n190:                         }\n191:                         if eq(T4, 2) {\n192:                             T1 := Q0\n193:                             T2 := Q1\n194:                         }\n195:                         if eq(T4, 3) {\n196:                             T1 := H0\n197:                             T2 := H1\n198:                         }\n199:                         if iszero(zz) {\n200:                             X := T1\n201:                             Y := T2\n202:                             zz := 1\n203:                             zzz := 1\n204:                             continue\n205:                         }\n206:                         // inlined EcZZ_AddN\n207: \n208:                         //T3:=sub(p, Y)\n209:                         //T3:=Y\n210:                         let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\n211:                         T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\n212: \n213:                         //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\n214:                         //todo : construct edge vector case\n215:                         if iszero(y2) {\n216:                             if iszero(T2) {\n217:                                 T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\n218:                                 T2 := mulmod(T1, T1, p) // V=U^2\n219:                                 T3 := mulmod(X, T2, p) // S = X1*V\n220: \n221:                                 T1 := mulmod(T1, T2, p) // W=UV\n222:                                 y2 := mulmod(addmod(X, zz, p), addmod(X, sub(p, zz), p), p) //(X-ZZ)(X+ZZ)\n223:                                 T4 := mulmod(3, y2, p) //M=3*(X-ZZ)(X+ZZ)\n224: \n225:                                 zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\n226:                                 zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\n227: \n228:                                 X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\n229:                                 T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\n230: \n231:                                 Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\n232: \n233:                                 continue\n234:                             }\n235:                         }\n236: \n237:                         T4 := mulmod(T2, T2, p) //PP\n238:                         let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\n239:                         zz := mulmod(zz, T4, p)\n240:                         zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\n241:                         let TT2 := mulmod(X, T4, p)\n242:                         T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\n243:                         Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\n244: \n245:                         X := T4\n246:                     }\n247:                 } //end loop\n248:                 let T := mload(0x40)\n249:                 mstore(add(T, 0x60), zz)\n250:                 //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\n251:                 //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\n252:                 // Define length of base, exponent and modulus. 0x20 == 32 bytes\n253:                 mstore(T, 0x20)\n254:                 mstore(add(T, 0x20), 0x20)\n255:                 mstore(add(T, 0x40), 0x20)\n256:                 // Define variables base, exponent and modulus\n257:                 //mstore(add(pointer, 0x60), u)\n258:                 mstore(add(T, 0x80), minus_2)\n259:                 mstore(add(T, 0xa0), p)\n260: \n261:                 // Call the precompiled contract 0x05 = ModExp\n262:                 if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\n263: \n264:                 //Y:=mulmod(Y,zzz,p)//Y/zzz\n265:                 //zz :=mulmod(zz, mload(T),p) //1/z\n266:                 //zz:= mulmod(zz,zz,p) //1/zz\n267:                 X := mulmod(X, mload(T), p) //X/zz\n268:             } //end assembly\n269:         } //end unchecked\n270: \n271:         return X;\n272:     }\n293:     function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) { \n294:         return (y == 0);\n295:     }\n374:     function FCL_pModInv(uint256 u) internal view returns (uint256 result) { \n375:         assembly {\n376:             let pointer := mload(0x40)\n377:             // Define length of base, exponent and modulus. 0x20 == 32 bytes\n378:             mstore(pointer, 0x20)\n379:             mstore(add(pointer, 0x20), 0x20)\n380:             mstore(add(pointer, 0x40), 0x20)\n381:             // Define variables base, exponent and modulus\n382:             mstore(add(pointer, 0x60), u)\n383:             mstore(add(pointer, 0x80), minus_2)\n384:             mstore(add(pointer, 0xa0), p)\n385: \n386:             // Call the precompiled contract 0x05 = ModExp\n387:             if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\n388:             result := mload(pointer)\n389:         }\n390:     }\n```\n",
          "loc": [
            "[94](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L94-L110)",
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L117-L272)",
            "[293](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L293-L295)",
            "[374](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L374-L390)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n137:     function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds) \n138:         public\n139:         payable\n140:         virtual\n141:         onlyEntryPoint\n142:         payPrefund(missingAccountFunds)\n143:         returns (uint256 validationData)\n144:     {\n145:         uint256 key = userOp.nonce >> 64;\n146: \n147:         // 0xbf6ba1fc = bytes4(keccak256(\"executeWithoutChainIdValidation(bytes)\"))\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) {\n149:             userOpHash = getUserOpHashWithoutChainId(userOp);\n150:             if (key != REPLAYABLE_NONCE_KEY) {\n151:                 revert InvalidNonceKey(key);\n152:             }\n153:         } else {\n154:             if (key == REPLAYABLE_NONCE_KEY) {\n155:                 revert InvalidNonceKey(key);\n156:             }\n157:         }\n158: \n159:         // Return 0 if the recovered address matches the owner.\n160:         if (_validateSignature(userOpHash, userOp.signature)) {\n161:             return 0;\n162:         }\n163: \n164:         // Else return 1, which is equivalent to:\n165:         // `(uint256(validAfter) << (160 + 48)) | (uint256(validUntil) << 160) | (success ? 0 : 1)`\n166:         // where `validUntil` is 0 (indefinite) and `validAfter` is 0.\n167:         return 1;\n168:     }\n229:     function getUserOpHashWithoutChainId(UserOperation calldata userOp) \n230:         public\n231:         view\n232:         virtual\n233:         returns (bytes32 userOpHash)\n234:     {\n235:         return keccak256(abi.encode(UserOperationLib.hash(userOp), entryPoint()));\n236:     }\n241:     function implementation() public view returns (address $) { \n242:         assembly {\n243:             $ := sload(_ERC1967_IMPLEMENTATION_SLOT)\n244:         }\n245:     }\n```\n",
          "loc": [
            "[137](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L137-L168)",
            "[229](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L229-L236)",
            "[241](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L241-L245)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n69:     function isValidSignature(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4 result) { \n70:         if (_validateSignature({message: replaySafeHash(hash), signature: signature})) {\n71:             // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n72:             return 0x1626ba7e;\n73:         }\n74: \n75:         return 0xffffffff;\n76:     }\n143:     function _domainNameAndVersion() internal view virtual returns (string memory name, string memory version); \n```\n",
          "loc": [
            "[69](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L69-L76)",
            "[143](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L143-L143)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n212:     function _getMultiOwnableStorage() internal pure returns (MultiOwnableStorage storage $) { \n213:         assembly (\"memory-safe\") {\n214:             $.slot := MUTLI_OWNABLE_STORAGE_LOCATION\n215:         }\n216:     }\n```\n",
          "loc": [
            "[212](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L212-L216)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Use != 0 instead of > 0 for unsigned integer comparison",
      "description": "Only valid prior to Solidity version 0.8.13, and only for `require()` statements, and at least one of those is not true for the examples below",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n160:         if (withdrawable > 0) { \n```\n",
          "loc": [
            "[160](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L160-L160)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Use assembly to emit events, in order to save gas",
      "description": "For these instances, the arguments are too large to fit in the scratch space, so the finding is invalid",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n323:         emit MagicSpendWithdrawal(account, withdrawRequest.asset, withdrawRequest.amount, withdrawRequest.nonce); \n```\n",
          "loc": [
            "[323](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L323)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Use SafeCast to safely cast variables",
      "description": "There's no risk of casting smaller type to a higher one",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/FreshCryptoLib/FCL.sol\n\n/// @audit bytes32 -> uint256\n61:         uint256 scalar_u = mulmod(uint256(message), sInv, n); \n```\n",
          "loc": [
            "[61](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/FreshCryptoLib/FCL.sol/#L61-L61)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n/// @audit uint48 -> uint256\n128:         validationData = (sigFailed ? 1 : 0) | (uint256(withdrawRequest.expiry) << 160); \n/// @audit contract MagicSpend -> address\n133:         if (address(this).balance < withdrawAmount) { \n/// @audit contract MagicSpend -> address\n134:             revert InsufficientBalance(withdrawAmount, address(this).balance);\n/// @audit contract MagicSpend -> address\n282:                 address(this), \n```\n",
          "loc": [
            "[128](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L128-L128)",
            "[133](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L133-L134)",
            "[282](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L282-L282)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWallet.sol\n\n/// @audit bytes calldata slice -> bytes4\n148:         if (userOp.callData.length >= 4 && bytes4(userOp.callData[0:4]) == 0xbf6ba1fc) { \n/// @audit bytes calldata slice -> bytes4\n181:         bytes4 selector = bytes4(data[0:4]); \n/// @audit contract CoinbaseSmartWallet -> address\n186:         _call(address(this), 0, data); \n/// @audit bytes32 -> uint256\n/// @audit bytes memory -> bytes32\n302:             if (uint256(bytes32(ownerBytes)) > type(uint160).max) { \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L148-L148)",
            "[181](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L181-L181)",
            "[186](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L186-L186)",
            "[302](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWallet.sol/#L302-L302)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/CoinbaseSmartWalletFactory.sol\n\n/// @audit address -> address\n51:         account = CoinbaseSmartWallet(payable(accountAddress)); \n/// @audit contract CoinbaseSmartWalletFactory -> address\n65:         predicted = LibClone.predictDeterministicAddress(initCodeHash(), _getSalt(owners, nonce), address(this)); \n```\n",
          "loc": [
            "[51](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L51-L51)",
            "[65](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/CoinbaseSmartWalletFactory.sol/#L65-L65)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit contract ERC1271 -> address\n53:         verifyingContract = address(this); \n/// @audit string memory -> bytes\n105:                 keccak256(bytes(name)), \n/// @audit string memory -> bytes\n106:                 keccak256(bytes(version)),\n/// @audit contract ERC1271 -> address\n108:                 address(this) \n```\n",
          "loc": [
            "[53](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L53-L53)",
            "[105](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L105-L106)",
            "[108](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L108-L108)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n/// @audit bytes32 -> uint256\n/// @audit bytes memory -> bytes32\n168:             if (owners[i].length == 32 && uint256(bytes32(owners[i])) > type(uint160).max) { \n/// @audit contract MultiOwnable -> address\n202:         if (isOwnerAddress(msg.sender) || (msg.sender == address(this))) { \n```\n",
          "loc": [
            "[168](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L168-L168)",
            "[202](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L202-L202)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit string memory -> bytes\n117:         if (keccak256(bytes(_type)) != EXPECTED_TYPE_HASH) { \n/// @audit string memory -> bytes\n122:         bytes memory expectedChallenge = bytes(string.concat('\"challenge\":\"', Base64.encodeURL(challenge), '\"')); \n/// @audit string memory -> bytes\n126:         if (keccak256(bytes(actualChallenge)) != keccak256(expectedChallenge)) { \n/// @audit string memory -> bytes\n145:         bytes32 clientDataJSONHash = sha256(bytes(webAuthnAuth.clientDataJSON)); \n```\n",
          "loc": [
            "[117](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L117-L117)",
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L122-L122)",
            "[126](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L126-L126)",
            "[145](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L145-L145)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning",
      "description": "These instances don't use only bytes/strings or the solidity pragma is below 0.8.12, so they're invalid",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/ERC1271.sol\n\n/// @audit solidity pragma is below 0.8.12\n122:         return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator(), _hashStruct(hash))); \n```\n",
          "loc": [
            "[122](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/ERC1271.sol/#L122-L122)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/WebAuthnSol/WebAuthn.sol\n\n/// @audit solidity pragma is below 0.8.12\n148:         bytes32 messageHash = sha256(abi.encodePacked(webAuthnAuth.authenticatorData, clientDataJSONHash)); \n```\n",
          "loc": [
            "[148](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/WebAuthnSol/WebAuthn.sol/#L148-L148)"
          ]
        }
      ]
    },
    {
      "severity": "Disputed",
      "title": "Using `bool`s for storage incurs overhead",
      "description": "The general rule is valid, but the instances below are invalid",
      "gasSavings": null,
      "category": null,
      "instances": [
        {
          "content": "```solidity\nüìÅ File: src/MagicSpend/MagicSpend.sol\n\n37:     mapping(uint256 nonce => mapping(address user => bool used)) internal _nonceUsed; \n```\n",
          "loc": [
            "[37](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/MagicSpend/MagicSpend.sol/#L37-L37)"
          ]
        },
        {
          "content": "```solidity\nüìÅ File: src/SmartWallet/MultiOwnable.sol\n\n24:     mapping(bytes account => bool isOwner_) isOwner; \n```\n",
          "loc": [
            "[24](https://github.com/code-423n4/2024-03-coinbase/blob/main/src/SmartWallet/MultiOwnable.sol/#L24-L24)"
          ]
        }
      ]
    }
  ],
  "createdAt": "2024-03-14T20:47:37.696Z",
  "updatedAt": "2024-03-14T20:47:38.620Z"
}